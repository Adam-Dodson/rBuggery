# This file is 90% autogenerated by munging dbgeng.h, with just
# enough Ruby to wrap the APIs in dispatch tables and then pass
# things off via method_missing.
#
# Author: Ben Nagy
# Copyright: Copyright (c) Ben Nagy, 2011.
# License: The MIT License
# (See README.TXT or http://www.opensource.org/licenses/mit-license.php for details.)
# THANKS: Park Heesob and Daniel Berger, couldn't have done it without their help.

require 'win32/api'

Memcpy = Win32::API.new('memcpy', 'PLL', 'L','msvcrt')
DebugCreate = Win32::API.new('DebugCreate', 'PP', 'L','dbgeng')
# These are parsed out from dbgeng.h
IIDS={
    'RawBuggery::DebugAdvanced'=>[0xf2df5f53, 0x071f, 0x47bd, 0x9d, 0xe6, 0x57, 0x34, 0xc3, 0xfe, 0xd6, 0x89].pack('LSSC8'),
    'RawBuggery::DebugAdvanced2'=>[0x716d14c9, 0x119b, 0x4ba5, 0xaf, 0x1f, 0x08, 0x90, 0xe6, 0x72, 0x41, 0x6a].pack('LSSC8'),
    'RawBuggery::DebugAdvanced3'=>[0xcba4abb4, 0x84c4, 0x444d, 0x87, 0xca, 0xa0, 0x4e, 0x13, 0x28, 0x67, 0x39].pack('LSSC8'),
    'RawBuggery::DebugBreakpoint'=>[0x5bd9d474, 0x5975, 0x423a, 0xb8, 0x8b, 0x65, 0xa8, 0xe7, 0x11, 0x0e, 0x65].pack('LSSC8'),
    'RawBuggery::DebugBreakpoint2'=>[0x1b278d20, 0x79f2, 0x426e, 0xa3, 0xf9, 0xc1, 0xdd, 0xf3, 0x75, 0xd4, 0x8e].pack('LSSC8'),
    'RawBuggery::DebugClient'=>[0x27fe5639, 0x8407, 0x4f47, 0x83, 0x64, 0xee, 0x11, 0x8f, 0xb0, 0x8a, 0xc8].pack('LSSC8'),
    'RawBuggery::DebugClient2'=>[0xedbed635, 0x372e, 0x4dab, 0xbb, 0xfe, 0xed, 0x0d, 0x2f, 0x63, 0xbe, 0x81].pack('LSSC8'),
    'RawBuggery::DebugClient3'=>[0xdd492d7f, 0x71b8, 0x4ad6, 0xa8, 0xdc, 0x1c, 0x88, 0x74, 0x79, 0xff, 0x91].pack('LSSC8'),
    'RawBuggery::DebugClient4'=>[0xca83c3de, 0x5089, 0x4cf8, 0x93, 0xc8, 0xd8, 0x92, 0x38, 0x7f, 0x2a, 0x5e].pack('LSSC8'),
    'RawBuggery::DebugClient5'=>[0xe3acb9d7, 0x7ec2, 0x4f0c, 0xa0, 0xda, 0xe8, 0x1e, 0x0c, 0xbb, 0xe6, 0x28].pack('LSSC8'),
    'RawBuggery::DebugControl'=>[0x5182e668, 0x105e, 0x416e, 0xad, 0x92, 0x24, 0xef, 0x80, 0x04, 0x24, 0xba].pack('LSSC8'),
    'RawBuggery::DebugControl2'=>[0xd4366723, 0x44df, 0x4bed, 0x8c, 0x7e, 0x4c, 0x05, 0x42, 0x4f, 0x45, 0x88].pack('LSSC8'),
    'RawBuggery::DebugControl3'=>[0x7df74a86, 0xb03f, 0x407f, 0x90, 0xab, 0xa2, 0x0d, 0xad, 0xce, 0xad, 0x08].pack('LSSC8'),
    'RawBuggery::DebugControl4'=>[0x94e60ce9, 0x9b41, 0x4b19, 0x9f, 0xc0, 0x6d, 0x9e, 0xb3, 0x52, 0x72, 0xb3].pack('LSSC8'),
    'RawBuggery::DebugDataSpaces'=>[0x88f7dfab, 0x3ea7, 0x4c3a, 0xae, 0xfb, 0xc4, 0xe8, 0x10, 0x61, 0x73, 0xaa].pack('LSSC8'),
    'RawBuggery::DebugDataSpaces2'=>[0x7a5e852f, 0x96e9, 0x468f, 0xac, 0x1b, 0x0b, 0x3a, 0xdd, 0xc4, 0xa0, 0x49].pack('LSSC8'),
    'RawBuggery::DebugDataSpaces3'=>[0x23f79d6c, 0x8aaf, 0x4f7c, 0xa6, 0x07, 0x99, 0x95, 0xf5, 0x40, 0x7e, 0x63].pack('LSSC8'),
    'RawBuggery::DebugDataSpaces4'=>[0xd98ada1f, 0x29e9, 0x4ef5, 0xa6, 0xc0, 0xe5, 0x33, 0x49, 0x88, 0x32, 0x12].pack('LSSC8'),
    'RawBuggery::DebugEventCallbacks'=>[0x337be28b, 0x5036, 0x4d72, 0xb6, 0xbf, 0xc4, 0x5f, 0xbb, 0x9f, 0x2e, 0xaa].pack('LSSC8'),
    'RawBuggery::DebugEventCallbacksWide'=>[0x0690e046, 0x9c23, 0x45ac, 0xa0, 0x4f, 0x98, 0x7a, 0xc2, 0x9a, 0xd0, 0xd3].pack('LSSC8'),
    'RawBuggery::DebugInputCallbacks'=>[0x9f50e42c, 0xf136, 0x499e, 0x9a, 0x97, 0x73, 0x03, 0x6c, 0x94, 0xed, 0x2d].pack('LSSC8'),
    'RawBuggery::DebugOutputCallbacks'=>[0x4bf58045, 0xd654, 0x4c40, 0xb0, 0xaf, 0x68, 0x30, 0x90, 0xf3, 0x56, 0xdc].pack('LSSC8'),
    'RawBuggery::DebugOutputCallbacksWide'=>[0x4c7fd663, 0xc394, 0x4e26, 0x8e, 0xf1, 0x34, 0xad, 0x5e, 0xd3, 0x76, 0x4c].pack('LSSC8'),
    'RawBuggery::DebugOutputCallbacks2'=>[0x67721fe9, 0x56d2, 0x4a44, 0xa3, 0x25, 0x2b, 0x65, 0x51, 0x3c, 0xe6, 0xeb].pack('LSSC8'),
    'RawBuggery::DebugRegisters'=>[0xce289126, 0x9e84, 0x45a7, 0x93, 0x7e, 0x67, 0xbb, 0x18, 0x69, 0x14, 0x93].pack('LSSC8'),
    'RawBuggery::DebugRegisters2'=>[0x1656afa9, 0x19c6, 0x4e3a, 0x97, 0xe7, 0x5d, 0xc9, 0x16, 0x0c, 0xf9, 0xc4].pack('LSSC8'),
    'RawBuggery::DebugSymbolGroup'=>[0xf2528316, 0x0f1a, 0x4431, 0xae, 0xed, 0x11, 0xd0, 0x96, 0xe1, 0xe2, 0xab].pack('LSSC8'),
    'RawBuggery::DebugSymbolGroup2'=>[0x6a7ccc5f, 0xfb5e, 0x4dcc, 0xb4, 0x1c, 0x6c, 0x20, 0x30, 0x7b, 0xcc, 0xc7].pack('LSSC8'),
    'RawBuggery::DebugSymbols'=>[0x8c31e98c, 0x983a, 0x48a5, 0x90, 0x16, 0x6f, 0xe5, 0xd6, 0x67, 0xa9, 0x50].pack('LSSC8'),
    'RawBuggery::DebugSymbols2'=>[0x3a707211, 0xafdd, 0x4495, 0xad, 0x4f, 0x56, 0xfe, 0xcd, 0xf8, 0x16, 0x3f].pack('LSSC8'),
    'RawBuggery::DebugSymbols3'=>[0xf02fbecc, 0x50ac, 0x4f36, 0x9a, 0xd9, 0xc9, 0x75, 0xe8, 0xf3, 0x2f, 0xf8].pack('LSSC8'),
    'RawBuggery::DebugSystemObjects'=>[0x6b86fe2c, 0x2c4f, 0x4f0c, 0x9d, 0xa2, 0x17, 0x43, 0x11, 0xac, 0xc3, 0x27].pack('LSSC8'),
    'RawBuggery::DebugSystemObjects2'=>[0x0ae9f5ff, 0x1852, 0x4679, 0xb0, 0x55, 0x49, 0x4b, 0xee, 0x64, 0x07, 0xee].pack('LSSC8'),
    'RawBuggery::DebugSystemObjects3'=>[0xe9676e2f, 0xe286, 0x4ea3, 0xb0, 0xf9, 0xdf, 0xe5, 0xd9, 0xfc, 0x33, 0x0e].pack('LSSC8'),
    'RawBuggery::DebugSystemObjects4'=>[0x489468e6, 0x7d0f, 0x4af5, 0x87, 0xab, 0x25, 0x20, 0x74, 0x54, 0xd5, 0x53].pack('LSSC8'),
}
IID_IUnknown=[0x00000000,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46].pack('LSSC8')
IID_IDispatch=[0x00020400,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46].pack('LSSC8')
S_OK=0
E_NOINTERFACE=1


module RawBuggery
    class FakeCOM
        # This class builds a fake COM object, which can be
        # used to implement IDebugOutputCallbacks, EventCallbacks etc.
        # Since we don't have any pretty wrapper around Win32 COM, and
        # it would suck to write a DLL which would have to be registered,
        # we cheat and just build the object raw in memory. A COM object is
        # basically just a pointer to a vtable at offset 0, and a vtable of
        # functions somewhere in memory. Don't try and get too fancy with
        # this stuff, it's pretty ghetto...
        def initialize
            # All objects need to implement these functions from IUnknown
            @QueryInterface = Win32::API::Callback.new('PPP','L',&lambda {|p,riid,ppv|
                if riid == IID_IUnknown || riid == IID_IDispatch
                    refcount = 0.chr * 4
                    memcpy(refcount,p+4,4)
                    refcount = [refcount.unpack('L').first + 1].pack('L')
                    memcpy(p+4,refcount,4)
                    ppv[0,4] = [p].pack('L')
                    return S_OK
                end
                E_NOINTERFACE
            })
            @AddRef = Win32::API::Callback.new('P','L') {|p|
                1
            }
            @Release = Win32::API::Callback.new('P','L') {|p|
                0
            }
            @vtable=[@QueryInterface,@AddRef,@Release]
        end

        # Add a new function to the end of the vtable.
        def add_function( arg_prototype, ret_prototype, &blk )
            raise ArgumentError "#{self.class}:#{__meth__}: Need a block to add!" unless block_given?
            @new=Win32::API::Callback.new(arg_prototype, ret_prototype, &blk)
            @vtable << @new
        end

        # Need to get the interface pointer AFTER you have completed your vtable.
        def interface_ptr
            # pack the callback addresses as an array in uint32 (pointers)
            # and then use the 'P' pack directive to get a pointer to 
            # that string.
            [@vtable.map {|cb| cb.address }.pack('L*')].pack('P')
        end
    end

=begin
    class Stub # EXAMPLE CLASS
        NUM_APIS=0 # fill in with correct number
        # Local Constants
        def initialize( parent )
            # Get a pointer to the interface
            p = 0.chr*4
            parent.QueryInterface(IIDS[self.class.to_s], p)
            @interface_ptr = p.unpack('L').first
            # *vtable
            lpVtbl = 0.chr * 4
            # malloc for vtable, NUM_APIS APIs * 4 byte addresses
            @vtable = 0.chr * 4*NUM_APIS
            # Copy *vtable from interface
            Memcpy.call(lpVtbl,@interface_ptr,4)
            # Copy vtable contents into @vtable
            Memcpy.call(@vtable,lpVtbl.unpack('L').first,4*NUM_APIS)
            # Unpack into an array of addresses
            @vtable=@vtable.unpack('L*')
            # These are autogenerated from dbgeng.h and may contain errors!
            @api_dispatch_table={
                # Fill in with the dispatch table
                # All interfaces will start like this...
                :QueryInterface=>Win32::API::Function.new(@vtable[0], 'PPP', 'L'),
                :AddRef=>Win32::API::Function.new(@vtable[1], 'P', 'L'),
                :Release=>Win32::API::Function.new(@vtable[2], 'P', 'L')
            }            
        end

        def ptr
            @interface_ptr
        end

        def method_missing( meth, *args )
            raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
            @api_dispatch_table[meth].call( @interface_ptr, *args )
        end
    end
=end

    class DebugClient
        # This class is a little bit special, because it will not only
        # dispatch to its own APIs from method_missing, but also to any
        # of the defined client interfaces, like DebugAdvanced, DebugRegisters etc

        # Local Constants
        DEBUG_ATTACH_KERNEL_CONNECTION=0x00000000
        DEBUG_ATTACH_LOCAL_KERNEL=0x00000001
        DEBUG_ATTACH_EXDI_DRIVER=0x00000002
        DEBUG_ATTACH_INSTALL_DRIVER=0x00000004
        DEBUG_GET_PROC_DEFAULT=0x00000000
        DEBUG_GET_PROC_FULL_MATCH=0x00000001
        DEBUG_GET_PROC_ONLY_MATCH=0x00000002
        DEBUG_GET_PROC_SERVICE_NAME=0x00000004
        DEBUG_PROC_DESC_DEFAULT=0x00000000
        DEBUG_PROC_DESC_NO_PATHS=0x00000001
        DEBUG_PROC_DESC_NO_SERVICES=0x00000002
        DEBUG_PROC_DESC_NO_MTS_PACKAGES=0x00000004
        DEBUG_PROC_DESC_NO_COMMAND_LINE=0x00000008
        DEBUG_PROC_DESC_NO_SESSION_ID=0x00000010
        DEBUG_PROC_DESC_NO_USER_NAME=0x00000020
        DEBUG_ATTACH_DEFAULT=0x00000000
        DEBUG_ATTACH_NONINVASIVE=0x00000001
        DEBUG_ATTACH_EXISTING=0x00000002
        DEBUG_ATTACH_NONINVASIVE_NO_SUSPEND=0x00000004
        DEBUG_ATTACH_INVASIVE_NO_INITIAL_BREAK=0x00000008
        DEBUG_ATTACH_INVASIVE_RESUME_PROCESS=0x00000010
        DEBUG_ATTACH_NONINVASIVE_ALLOW_PARTIAL=0x00000020
        # Don't know where to find these at the moment
        #DEBUG_CREATE_PROCESS_NO_DEBUG_HEAP=CREATE_UNICODE_ENVIRONMENT
        #DEBUG_CREATE_PROCESS_THROUGH_RTL=STACK_SIZE_PARAM_IS_A_RESERVATION
        DEBUG_ECREATE_PROCESS_DEFAULT=0x00000000
        DEBUG_ECREATE_PROCESS_INHERIT_HANDLES=0x00000001
        DEBUG_ECREATE_PROCESS_USE_VERIFIER_FLAGS=0x00000002
        DEBUG_ECREATE_PROCESS_USE_IMPLICIT_COMMAND_LINE=0x00000004
        DEBUG_PROCESS_DETACH_ON_EXIT=0x00000001
        DEBUG_PROCESS_ONLY_THIS_PROCESS=0x00000002
        DEBUG_CONNECT_SESSION_DEFAULT=0x00000000
        DEBUG_CONNECT_SESSION_NO_VERSION=0x00000001
        DEBUG_CONNECT_SESSION_NO_ANNOUNCE=0x00000002
        DEBUG_SERVERS_DEBUGGER=0x00000001
        DEBUG_SERVERS_PROCESS=0x00000002
        DEBUG_SERVERS_ALL=0x00000003
        DEBUG_END_PASSIVE=0x00000000
        DEBUG_END_ACTIVE_TERMINATE=0x00000001
        DEBUG_END_ACTIVE_DETACH=0x00000002
        DEBUG_END_REENTRANT=0x00000003
        DEBUG_END_DISCONNECT=0x00000004
        DEBUG_OUTPUT_NORMAL=0x00000001
        DEBUG_OUTPUT_ERROR=0x00000002
        DEBUG_OUTPUT_WARNING=0x00000004
        DEBUG_OUTPUT_VERBOSE=0x00000008
        DEBUG_OUTPUT_PROMPT=0x00000010
        DEBUG_OUTPUT_PROMPT_REGISTERS=0x00000020
        DEBUG_OUTPUT_EXTENSION_WARNING=0x00000040
        DEBUG_OUTPUT_DEBUGGEE=0x00000080
        DEBUG_OUTPUT_DEBUGGEE_PROMPT=0x00000100
        DEBUG_OUTPUT_SYMBOLS=0x00000200
        DEBUG_IOUTPUT_KD_PROTOCOL=0x80000000
        DEBUG_IOUTPUT_REMOTING=0x40000000
        DEBUG_IOUTPUT_BREAKPOINT=0x20000000
        DEBUG_IOUTPUT_EVENT=0x10000000
        DEBUG_IOUTPUT_ADDR_TRANSLATE=0x08000000
        DEBUG_OUTPUT_IDENTITY_DEFAULT=0x00000000

        def initialize
            # Get a pointer to the IDebugClient interface
            ptr = 0.chr*4
            DebugCreate.call(IIDS[self.class.to_s],ptr)
            @interface_ptr = ptr.unpack('L').first
            raise "#{self.class}: Unable to get interface pointer!" if @interface_ptr.zero?
            # *vtable
            lpVtbl = 0.chr * 4
            # malloc for vtable, 48 APIs * 4 byte addresses
            @vtable = 0.chr * 4*48
            # Copy *vtable from interface
            Memcpy.call(lpVtbl,@interface_ptr,4)
            # Copy vtable contents into @vtable
            Memcpy.call(@vtable,lpVtbl.unpack('L').first,4*48)
            # Unpack into an array of addresses
            @vtable=@vtable.unpack('L*')
            @interface_table={} # empty for now, built as needed
            # These are autogenerated from dbgeng.h and may contain errors!
            @api_dispatch_table={
                :QueryInterface=>Win32::API::Function.new(@vtable[0], 'PPP', 'L'),
                :AddRef=>Win32::API::Function.new(@vtable[1], 'P', 'L'),
                :Release=>Win32::API::Function.new(@vtable[2], 'P', 'L'),
                :AttachKernel=>Win32::API::Function.new(@vtable[3], 'PLP', 'L'),
                :GetKernelConnectionOptions=>Win32::API::Function.new(@vtable[4], 'PPLP', 'L'),
                :SetKernelConnectionOptions=>Win32::API::Function.new(@vtable[5], 'PP', 'L'),
                :StartProcessServer=>Win32::API::Function.new(@vtable[6], 'PLP', 'L'),
                :ConnectProcessServer=>Win32::API::Function.new(@vtable[7], 'PPP', 'L'),
                :DisconnectProcessServer=>Win32::API::Function.new(@vtable[8], 'PLL', 'L'),
                :GetRunningProcessSystemIds=>Win32::API::Function.new(@vtable[9], 'PLLPLP', 'L'),
                :GetRunningProcessSystemIdByExecutableName=>Win32::API::Function.new(@vtable[10], 'PLLPLP', 'L'),
                :GetRunningProcessDescription=>Win32::API::Function.new(@vtable[11], 'PLLLLPLPPLP', 'L'),
                :AttachProcess=>Win32::API::Function.new(@vtable[12], 'PLLLL', 'L'),
                :CreateProcess=>Win32::API::Function.new(@vtable[13], 'PLLPL', 'L'),
                :CreateProcessAndAttach=>Win32::API::Function.new(@vtable[14], 'PLLPLLL', 'L'),
                :GetProcessOptions=>Win32::API::Function.new(@vtable[15], 'PP', 'L'),
                :AddProcessOptions=>Win32::API::Function.new(@vtable[16], 'PL', 'L'),
                :RemoveProcessOptions=>Win32::API::Function.new(@vtable[17], 'PL', 'L'),
                :SetProcessOptions=>Win32::API::Function.new(@vtable[18], 'PL', 'L'),
                :OpenDumpFile=>Win32::API::Function.new(@vtable[19], 'PP', 'L'),
                :WriteDumpFile=>Win32::API::Function.new(@vtable[20], 'PPL', 'L'),
                :ConnectSession=>Win32::API::Function.new(@vtable[21], 'PLL', 'L'),
                :StartServer=>Win32::API::Function.new(@vtable[22], 'PP', 'L'),
                :OutputServers=>Win32::API::Function.new(@vtable[23], 'PLPL', 'L'),
                :TerminateProcesses=>Win32::API::Function.new(@vtable[24], 'P', 'L'),
                :DetachProcesses=>Win32::API::Function.new(@vtable[25], 'P', 'L'),
                :EndSession=>Win32::API::Function.new(@vtable[26], 'PL', 'L'),
                :GetExitCode=>Win32::API::Function.new(@vtable[27], 'PP', 'L'),
                :DispatchCallbacks=>Win32::API::Function.new(@vtable[28], 'PL', 'L'),
                :ExitDispatch=>Win32::API::Function.new(@vtable[29], 'PP', 'L'),
                :CreateClient=>Win32::API::Function.new(@vtable[30], 'PP', 'L'),
                :GetInputCallbacks=>Win32::API::Function.new(@vtable[31], 'PP', 'L'),
                :SetInputCallbacks=>Win32::API::Function.new(@vtable[32], 'PP', 'L'),
                :GetOutputCallbacks=>Win32::API::Function.new(@vtable[33], 'PP', 'L'),
                :SetOutputCallbacks=>Win32::API::Function.new(@vtable[34], 'PP', 'L'),
                :GetOutputMask=>Win32::API::Function.new(@vtable[35], 'PP', 'L'),
                :SetOutputMask=>Win32::API::Function.new(@vtable[36], 'PL', 'L'),
                :GetOtherOutputMask=>Win32::API::Function.new(@vtable[37], 'PPP', 'L'),
                :SetOtherOutputMask=>Win32::API::Function.new(@vtable[38], 'PPL', 'L'),
                :GetOutputWidth=>Win32::API::Function.new(@vtable[39], 'PP', 'L'),
                :SetOutputWidth=>Win32::API::Function.new(@vtable[40], 'PL', 'L'),
                :GetOutputLinePrefix=>Win32::API::Function.new(@vtable[41], 'PPLP', 'L'),
                :SetOutputLinePrefix=>Win32::API::Function.new(@vtable[42], 'PP', 'L'),
                :GetIdentity=>Win32::API::Function.new(@vtable[43], 'PPLP', 'L'),
                :OutputIdentity=>Win32::API::Function.new(@vtable[44], 'PLLP', 'L'),
                :GetEventCallbacks=>Win32::API::Function.new(@vtable[45], 'PP', 'L'),
                :SetEventCallbacks=>Win32::API::Function.new(@vtable[46], 'PP', 'L'),
                :FlushCallbacks=>Win32::API::Function.new(@vtable[47], 'P', 'L')
            }            
        end

        def ptr
            @interface_ptr
        end

        def method_missing( meth, *args )
            unless @api_dispatch_table[meth]
                begin
                    # Maybe it's a subinterface?
                    @interface_table[meth]||=RawBuggery.const_get( meth ).new( self )
                rescue
                    # Then again, maybe not.
                    raise ArgumentError, "#{self.class}: Invalid API #{meth}" 
                end
            else
                @api_dispatch_table[meth].call( @interface_ptr, *args )
            end
        end
    end

    class DebugRegisters
        # Interface ID
        NUM_APIS=14
        # Local Constants
        DEBUG_REGISTERS_DEFAULT=0x00000000
        DEBUG_REGISTERS_INT32=0x00000001
        DEBUG_REGISTERS_INT64=0x00000002
        DEBUG_REGISTERS_FLOAT=0x00000004
        DEBUG_REGISTERS_ALL=0x00000007
        DEBUG_REGISTER_SUB_REGISTER=0x00000001
        def initialize( parent )
            # Get a pointer to the interface
            p = 0.chr*4
            parent.QueryInterface(IIDS[self.class.to_s], p)
            @interface_ptr = p.unpack('L').first
            raise "#{self.class}: Unable to get interface pointer!" if @interface_ptr.zero?
            # *vtable
            lpVtbl = 0.chr * 4
            # malloc for vtable, NUM_APIS APIs * 4 byte addresses
            @vtable = 0.chr * 4*NUM_APIS
            # Copy *vtable from interface
            Memcpy.call(lpVtbl,@interface_ptr,4)
            # Copy vtable contents into @vtable
            Memcpy.call(@vtable,lpVtbl.unpack('L').first,4*NUM_APIS)
            # Unpack into an array of addresses
            @vtable=@vtable.unpack('L*')
            # These are autogenerated from dbgeng.h and may contain errors!
            @api_dispatch_table={
                :QueryInterface=>Win32::API::Function.new(@vtable[0], 'PPP', 'L'),
                :AddRef=>Win32::API::Function.new(@vtable[1], 'P', 'L'),
                :Release=>Win32::API::Function.new(@vtable[2], 'P', 'L'),
                :GetNumberRegisters=>Win32::API::Function.new(@vtable[3], 'PP', 'L'),
                :GetDescription=>Win32::API::Function.new(@vtable[4], 'PLPLPP', 'L'),
                :GetIndexByName=>Win32::API::Function.new(@vtable[5], 'PPP', 'L'),
                :GetValue=>Win32::API::Function.new(@vtable[6], 'PLP', 'L'),
                :SetValue=>Win32::API::Function.new(@vtable[7], 'PLP', 'L'),
                :GetValues=>Win32::API::Function.new(@vtable[8], 'PLPLP', 'L'),
                :SetValues=>Win32::API::Function.new(@vtable[9], 'PLPLP', 'L'),
                :OutputRegisters=>Win32::API::Function.new(@vtable[10], 'PLL', 'L'),
                :GetInstructionOffset=>Win32::API::Function.new(@vtable[11], 'PP', 'L'),
                :GetStackOffset=>Win32::API::Function.new(@vtable[12], 'PP', 'L'),
                :GetFrameOffset=>Win32::API::Function.new(@vtable[13], 'PP', 'L')
            }            
        end

        def ptr
            @interface_ptr
        end

        def method_missing( meth, *args )
            raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
            @api_dispatch_table[meth].call( @interface_ptr, *args )
        end
    end

    class DebugControl
        # Local Constants
        DEBUG_STATUS_NO_CHANGE=0
        DEBUG_STATUS_GO=1
        DEBUG_STATUS_GO_HANDLED=2
        DEBUG_STATUS_GO_NOT_HANDLED=3
        DEBUG_STATUS_STEP_OVER=4
        DEBUG_STATUS_STEP_INTO=5
        DEBUG_STATUS_BREAK=6
        DEBUG_STATUS_NO_DEBUGGEE=7
        DEBUG_STATUS_STEP_BRANCH=8
        DEBUG_STATUS_IGNORE_EVENT=9
        DEBUG_STATUS_RESTART_REQUESTED=10
        DEBUG_STATUS_REVERSE_GO=11
        DEBUG_STATUS_REVERSE_STEP_BRANCH=12
        DEBUG_STATUS_REVERSE_STEP_OVER=13
        DEBUG_STATUS_REVERSE_STEP_INTO=14
        DEBUG_STATUS_MASK=0xf
        DEBUG_STATUS_INSIDE_WAIT=0x100000000
        DEBUG_STATUS_WAIT_TIMEOUT=0x200000000
        DEBUG_OUTCTL_THIS_CLIENT=0x00000000
        DEBUG_OUTCTL_ALL_CLIENTS=0x00000001
        DEBUG_OUTCTL_ALL_OTHER_CLIENTS=0x00000002
        DEBUG_OUTCTL_IGNORE=0x00000003
        DEBUG_OUTCTL_LOG_ONLY=0x00000004
        DEBUG_OUTCTL_SEND_MASK=0x00000007
        DEBUG_OUTCTL_NOT_LOGGED=0x00000008
        DEBUG_OUTCTL_OVERRIDE_MASK=0x00000010
        DEBUG_OUTCTL_DML=0x00000020
        DEBUG_OUTCTL_AMBIENT_DML=0xfffffffe
        DEBUG_OUTCTL_AMBIENT_TEXT=0xffffffff
        #DEBUG_OUTCTL_AMBIENT=DEBUG_OUTCTL_AMBIENT_TEXT
        DEBUG_INTERRUPT_ACTIVE=0
        DEBUG_INTERRUPT_PASSIVE=1
        DEBUG_INTERRUPT_EXIT=2
        DEBUG_CURRENT_DEFAULT=0x0000000f
        DEBUG_CURRENT_SYMBOL=0x00000001
        DEBUG_CURRENT_DISASM=0x00000002
        DEBUG_CURRENT_REGISTERS=0x00000004
        DEBUG_CURRENT_SOURCE_LINE=0x00000008
        DEBUG_DISASM_EFFECTIVE_ADDRESS=0x00000001
        DEBUG_DISASM_MATCHING_SYMBOLS=0x00000002
        DEBUG_DISASM_SOURCE_LINE_NUMBER=0x00000004
        DEBUG_DISASM_SOURCE_FILE_NAME=0x00000008
        DEBUG_LEVEL_SOURCE=0
        DEBUG_LEVEL_ASSEMBLY=1
        DEBUG_ENGOPT_IGNORE_DBGHELP_VERSION=0x00000001
        DEBUG_ENGOPT_IGNORE_EXTENSION_VERSIONS=0x00000002
        DEBUG_ENGOPT_ALLOW_NETWORK_PATHS=0x00000004
        DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS=0x00000008
        DEBUG_ENGOPT_NETWORK_PATHS=(0x00000004|0x00000008)
        DEBUG_ENGOPT_IGNORE_LOADER_EXCEPTIONS=0x00000010
        DEBUG_ENGOPT_INITIAL_BREAK=0x00000020
        DEBUG_ENGOPT_INITIAL_MODULE_BREAK=0x00000040
        DEBUG_ENGOPT_FINAL_BREAK=0x00000080
        DEBUG_ENGOPT_NO_EXECUTE_REPEAT=0x00000100
        DEBUG_ENGOPT_FAIL_INCOMPLETE_INFORMATION=0x00000200
        DEBUG_ENGOPT_ALLOW_READ_ONLY_BREAKPOINTS=0x00000400
        DEBUG_ENGOPT_SYNCHRONIZE_BREAKPOINTS=0x00000800
        DEBUG_ENGOPT_DISALLOW_SHELL_COMMANDS=0x00001000
        DEBUG_ENGOPT_KD_QUIET_MODE=0x00002000
        DEBUG_ENGOPT_DISABLE_MANAGED_SUPPORT=0x00004000
        DEBUG_ENGOPT_DISABLE_MODULE_SYMBOL_LOAD=0x00008000
        DEBUG_ENGOPT_DISABLE_EXECUTION_COMMANDS=0x00010000
        DEBUG_ENGOPT_DISALLOW_IMAGE_FILE_MAPPING=0x00020000
        DEBUG_ENGOPT_PREFER_DML=0x00040000
        DEBUG_ENGOPT_ALL=0x0007FFFF
        DEBUG_ANY_ID=0xffffffff
        DEBUG_STACK_ARGUMENTS=0x00000001
        DEBUG_STACK_FUNCTION_INFO=0x00000002
        DEBUG_STACK_SOURCE_LINE=0x00000004
        DEBUG_STACK_FRAME_ADDRESSES=0x00000008
        DEBUG_STACK_COLUMN_NAMES=0x00000010
        DEBUG_STACK_NONVOLATILE_REGISTERS=0x00000020
        DEBUG_STACK_FRAME_NUMBERS=0x00000040
        DEBUG_STACK_PARAMETERS=0x00000080
        DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY=0x00000100
        DEBUG_STACK_FRAME_MEMORY_USAGE=0x00000200
        DEBUG_STACK_PARAMETERS_NEWLINE=0x00000400
        DEBUG_STACK_DML=0x00000800
        DEBUG_STACK_FRAME_OFFSETS=0x00001000
        DEBUG_CLASS_UNINITIALIZED=0
        DEBUG_CLASS_KERNEL=1
        DEBUG_CLASS_USER_WINDOWS=2
        DEBUG_CLASS_IMAGE_FILE=3
        DEBUG_DUMP_SMALL=1024
        DEBUG_DUMP_DEFAULT=1025
        DEBUG_DUMP_FULL=1026
        DEBUG_DUMP_IMAGE_FILE=1027
        DEBUG_DUMP_TRACE_LOG=1028
        DEBUG_DUMP_WINDOWS_CE=1029
        DEBUG_KERNEL_CONNECTION=0
        DEBUG_KERNEL_LOCAL=1
        DEBUG_KERNEL_EXDI_DRIVER=2
        DEBUG_KERNEL_IDNA=3
        DEBUG_KERNEL_INSTALL_DRIVER=4
        DEBUG_KERNEL_SMALL_DUMP=DEBUG_DUMP_SMALL
        DEBUG_KERNEL_DUMP=DEBUG_DUMP_DEFAULT
        DEBUG_KERNEL_FULL_DUMP=DEBUG_DUMP_FULL
        DEBUG_KERNEL_TRACE_LOG=DEBUG_DUMP_TRACE_LOG
        DEBUG_USER_WINDOWS_PROCESS=0
        DEBUG_USER_WINDOWS_PROCESS_SERVER=1
        DEBUG_USER_WINDOWS_IDNA=2
        DEBUG_USER_WINDOWS_SMALL_DUMP=DEBUG_DUMP_SMALL
        DEBUG_USER_WINDOWS_DUMP=DEBUG_DUMP_DEFAULT
        DEBUG_USER_WINDOWS_DUMP_WINDOWS_CE=DEBUG_DUMP_WINDOWS_CE
        DEBUG_EXTENSION_AT_ENGINE=0x00000000
        DEBUG_EXECUTE_DEFAULT=0x00000000
        DEBUG_EXECUTE_ECHO=0x00000001
        DEBUG_EXECUTE_NOT_LOGGED=0x00000002
        DEBUG_EXECUTE_NO_REPEAT=0x00000004
        DEBUG_FILTER_CREATE_THREAD=0x00000000
        DEBUG_FILTER_EXIT_THREAD=0x00000001
        DEBUG_FILTER_CREATE_PROCESS=0x00000002
        DEBUG_FILTER_EXIT_PROCESS=0x00000003
        DEBUG_FILTER_LOAD_MODULE=0x00000004
        DEBUG_FILTER_UNLOAD_MODULE=0x00000005
        DEBUG_FILTER_SYSTEM_ERROR=0x00000006
        DEBUG_FILTER_INITIAL_BREAKPOINT=0x00000007
        DEBUG_FILTER_INITIAL_MODULE_LOAD=0x00000008
        DEBUG_FILTER_DEBUGGEE_OUTPUT=0x00000009
        DEBUG_FILTER_BREAK=0x00000000
        DEBUG_FILTER_SECOND_CHANCE_BREAK=0x00000001
        DEBUG_FILTER_OUTPUT=0x00000002
        DEBUG_FILTER_IGNORE=0x00000003
        DEBUG_FILTER_REMOVE=0x00000004
        DEBUG_FILTER_GO_HANDLED=0x00000000
        DEBUG_FILTER_GO_NOT_HANDLED=0x00000001
        DEBUG_WAIT_DEFAULT=0x00000000
        DEBUG_VALUE_INVALID=0
        DEBUG_VALUE_INT8=1
        DEBUG_VALUE_INT16=2
        DEBUG_VALUE_INT32=3
        DEBUG_VALUE_INT64=4
        DEBUG_VALUE_FLOAT32=5
        DEBUG_VALUE_FLOAT64=6
        DEBUG_VALUE_FLOAT80=7
        DEBUG_VALUE_FLOAT82=8
        DEBUG_VALUE_FLOAT128=9
        DEBUG_VALUE_VECTOR64=10
        DEBUG_VALUE_VECTOR128=11
        DEBUG_VALUE_TYPES=12

        NUM_APIS=95

        def initialize( parent )
            # Get a pointer to the interface
            p=0.chr*4
            parent.QueryInterface(IIDS[self.class.to_s], p)
            @interface_ptr = p.unpack('L').first
            raise "#{self.class}: Unable to get interface pointer!" if @interface_ptr.zero?
            # *vtable
            lpVtbl = 0.chr * 4
            # malloc for vtable, NUM_APIS APIs * 4 byte addresses
            @vtable = 0.chr * 4*NUM_APIS
            # Copy *vtable from interface
            Memcpy.call(lpVtbl,@interface_ptr,4)
            # Copy vtable contents into @vtable
            Memcpy.call(@vtable,lpVtbl.unpack('L').first,4*NUM_APIS)
            # Unpack into an array of addresses
            @vtable=@vtable.unpack('L*')
            # These are autogenerated from dbgeng.h and may contain errors!
            @api_dispatch_table={
                :QueryInterface=>Win32::API::Function.new(@vtable[0], 'PPP', 'L'),
                :AddRef=>Win32::API::Function.new(@vtable[1], 'P', 'L'),
                :Release=>Win32::API::Function.new(@vtable[2], 'P', 'L'),
                :GetInterrupt=>Win32::API::Function.new(@vtable[3], 'P', 'L'),
                :SetInterrupt=>Win32::API::Function.new(@vtable[4], 'PL', 'L'),
                :GetInterruptTimeout=>Win32::API::Function.new(@vtable[5], 'PP', 'L'),
                :SetInterruptTimeout=>Win32::API::Function.new(@vtable[6], 'PL', 'L'),
                :GetLogFile=>Win32::API::Function.new(@vtable[7], 'PPLPP', 'L'),
                :OpenLogFile=>Win32::API::Function.new(@vtable[8], 'PPI', 'L'),
                :CloseLogFile=>Win32::API::Function.new(@vtable[9], 'P', 'L'),
                :GetLogMask=>Win32::API::Function.new(@vtable[10], 'PP', 'L'),
                :SetLogMask=>Win32::API::Function.new(@vtable[11], 'PL', 'L'),
                :Input=>Win32::API::Function.new(@vtable[12], 'PPLP', 'L'),
                :ReturnInput=>Win32::API::Function.new(@vtable[13], 'PP', 'L'),
                :Output=>Win32::API::Function.new(@vtable[14], 'PLP', 'L'),
                :OutputVaList=>Win32::API::Function.new(@vtable[15], 'PLP', 'L'),
                :ControlledOutput=>Win32::API::Function.new(@vtable[16], 'PLLP', 'L'),
                :ControlledOutputVaList=>Win32::API::Function.new(@vtable[17], 'PLLP', 'L'),
                :OutputPrompt=>Win32::API::Function.new(@vtable[18], 'PLP', 'L'),
                :OutputPromptVaList=>Win32::API::Function.new(@vtable[19], 'PLP', 'L'),
                :GetPromptText=>Win32::API::Function.new(@vtable[20], 'PPLP', 'L'),
                :OutputCurrentState=>Win32::API::Function.new(@vtable[21], 'PLL', 'L'),
                :OutputVersionInformation=>Win32::API::Function.new(@vtable[22], 'PL', 'L'),
                :GetNotifyEventHandle=>Win32::API::Function.new(@vtable[23], 'PP', 'L'),
                :SetNotifyEventHandle=>Win32::API::Function.new(@vtable[24], 'PLL', 'L'),
                :Assemble=>Win32::API::Function.new(@vtable[25], 'PLLPP', 'L'),
                :Disassemble=>Win32::API::Function.new(@vtable[26], 'PLLLPLPP', 'L'),
                :GetDisassembleEffectiveOffset=>Win32::API::Function.new(@vtable[27], 'PP', 'L'),
                :OutputDisassembly=>Win32::API::Function.new(@vtable[28], 'PLLLLP', 'L'),
                :OutputDisassemblyLines=>Win32::API::Function.new(@vtable[29], 'PLLLLLLPPPP', 'L'),
                :GetNearInstruction=>Win32::API::Function.new(@vtable[30], 'PLLLP', 'L'),
                :GetStackTrace=>Win32::API::Function.new(@vtable[31], 'PLLLLLLPLP', 'L'),
                :GetReturnOffset=>Win32::API::Function.new(@vtable[32], 'PP', 'L'),
                :OutputStackTrace=>Win32::API::Function.new(@vtable[33], 'PLPLL', 'L'),
                :GetDebuggeeType=>Win32::API::Function.new(@vtable[34], 'PPP', 'L'),
                :GetActualProcessorType=>Win32::API::Function.new(@vtable[35], 'PP', 'L'),
                :GetExecutingProcessorType=>Win32::API::Function.new(@vtable[36], 'PP', 'L'),
                :GetNumberPossibleExecutingProcessorTypes=>Win32::API::Function.new(@vtable[37], 'PP', 'L'),
                :GetPossibleExecutingProcessorTypes=>Win32::API::Function.new(@vtable[38], 'PLLP', 'L'),
                :GetNumberProcessors=>Win32::API::Function.new(@vtable[39], 'PP', 'L'),
                :GetSystemVersion=>Win32::API::Function.new(@vtable[40], 'PPPPPLPPPLP', 'L'),
                :GetPageSize=>Win32::API::Function.new(@vtable[41], 'PP', 'L'),
                :IsPointer64Bit=>Win32::API::Function.new(@vtable[42], 'P', 'L'),
                :ReadBugCheckData=>Win32::API::Function.new(@vtable[43], 'PPPPPP', 'L'),
                :GetNumberSupportedProcessorTypes=>Win32::API::Function.new(@vtable[44], 'PP', 'L'),
                :GetSupportedProcessorTypes=>Win32::API::Function.new(@vtable[45], 'PLLP', 'L'),
                :GetProcessorTypeNames=>Win32::API::Function.new(@vtable[46], 'PLPLPPLP', 'L'),
                :GetEffectiveProcessorType=>Win32::API::Function.new(@vtable[47], 'PP', 'L'),
                :SetEffectiveProcessorType=>Win32::API::Function.new(@vtable[48], 'PL', 'L'),
                :GetExecutionStatus=>Win32::API::Function.new(@vtable[49], 'PP', 'L'),
                :SetExecutionStatus=>Win32::API::Function.new(@vtable[50], 'PL', 'L'),
                :GetCodeLevel=>Win32::API::Function.new(@vtable[51], 'PP', 'L'),
                :SetCodeLevel=>Win32::API::Function.new(@vtable[52], 'PL', 'L'),
                :GetEngineOptions=>Win32::API::Function.new(@vtable[53], 'PP', 'L'),
                :AddEngineOptions=>Win32::API::Function.new(@vtable[54], 'PL', 'L'),
                :RemoveEngineOptions=>Win32::API::Function.new(@vtable[55], 'PL', 'L'),
                :SetEngineOptions=>Win32::API::Function.new(@vtable[56], 'PL', 'L'),
                :GetSystemErrorControl=>Win32::API::Function.new(@vtable[57], 'PPP', 'L'),
                :SetSystemErrorControl=>Win32::API::Function.new(@vtable[58], 'PLL', 'L'),
                :GetTextMacro=>Win32::API::Function.new(@vtable[59], 'PLPLP', 'L'),
                :SetTextMacro=>Win32::API::Function.new(@vtable[60], 'PLP', 'L'),
                :GetRadix=>Win32::API::Function.new(@vtable[61], 'PP', 'L'),
                :SetRadix=>Win32::API::Function.new(@vtable[62], 'PL', 'L'),
                :Evaluate=>Win32::API::Function.new(@vtable[63], 'PPLPP', 'L'),
                :CoerceValue=>Win32::API::Function.new(@vtable[64], 'PPLP', 'L'),
                :CoerceValues=>Win32::API::Function.new(@vtable[65], 'PLPPP', 'L'),
                :Execute=>Win32::API::Function.new(@vtable[66], 'PLPL', 'L'),
                :ExecuteCommandFile=>Win32::API::Function.new(@vtable[67], 'PLPL', 'L'),
                :GetNumberBreakpoints=>Win32::API::Function.new(@vtable[68], 'PP', 'L'),
                :GetBreakpointByIndex=>Win32::API::Function.new(@vtable[69], 'PLP', 'L'),
                :GetBreakpointById=>Win32::API::Function.new(@vtable[70], 'PLP', 'L'),
                :GetBreakpointParameters=>Win32::API::Function.new(@vtable[71], 'PLPLP', 'L'),
                :AddBreakpoint=>Win32::API::Function.new(@vtable[72], 'PLLP', 'L'),
                :RemoveBreakpoint=>Win32::API::Function.new(@vtable[73], 'PP', 'L'),
                :AddExtension=>Win32::API::Function.new(@vtable[74], 'PPLP', 'L'),
                :RemoveExtension=>Win32::API::Function.new(@vtable[75], 'PLL', 'L'),
                :GetExtensionByPath=>Win32::API::Function.new(@vtable[76], 'PPP', 'L'),
                :CallExtension=>Win32::API::Function.new(@vtable[77], 'PLLPP', 'L'),
                :GetExtensionFunction=>Win32::API::Function.new(@vtable[78], 'PLLP', 'L'),
                :GetWindbgExtensionApis32=>Win32::API::Function.new(@vtable[79], 'PP', 'L'),
                :GetWindbgExtensionApis64=>Win32::API::Function.new(@vtable[80], 'PP', 'L'),
                :GetNumberEventFilters=>Win32::API::Function.new(@vtable[81], 'PPPP', 'L'),
                :GetEventFilterText=>Win32::API::Function.new(@vtable[82], 'PLPLP', 'L'),
                :GetEventFilterCommand=>Win32::API::Function.new(@vtable[83], 'PLPLP', 'L'),
                :SetEventFilterCommand=>Win32::API::Function.new(@vtable[84], 'PLP', 'L'),
                :GetSpecificFilterParameters=>Win32::API::Function.new(@vtable[85], 'PLLP', 'L'),
                :SetSpecificFilterParameters=>Win32::API::Function.new(@vtable[86], 'PLLP', 'L'),
                :GetSpecificFilterArgument=>Win32::API::Function.new(@vtable[87], 'PLPLP', 'L'),
                :SetSpecificFilterArgument=>Win32::API::Function.new(@vtable[88], 'PLP', 'L'),
                :GetExceptionFilterParameters=>Win32::API::Function.new(@vtable[89], 'PLPLP', 'L'),
                :SetExceptionFilterParameters=>Win32::API::Function.new(@vtable[90], 'PLP', 'L'),
                :GetExceptionFilterSecondCommand=>Win32::API::Function.new(@vtable[91], 'PLPLP', 'L'),
                :SetExceptionFilterSecondCommand=>Win32::API::Function.new(@vtable[92], 'PLP', 'L'),
                :WaitForEvent=>Win32::API::Function.new(@vtable[93], 'PLL', 'L'),
                :GetLastEventInformation=>Win32::API::Function.new(@vtable[94], 'PPPPPLPPLP', 'L')
            }            
        end

        def ptr
            @interface_ptr
        end

        def method_missing( meth, *args )
            raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
            @api_dispatch_table[meth].call( @interface_ptr, *args )
        end
    end

    class DebugAdvanced
        NUM_APIS=5
        # Local Constants
        def initialize( parent )
            # Get a pointer to the interface
            p = 0.chr*4
            parent.QueryInterface(IIDS[self.class.to_s], p)
            @interface_ptr = p.unpack('L').first
            raise "#{self.class}: Unable to get interface pointer!" if @interface_ptr.zero?
            # *vtable
            lpVtbl = 0.chr * 4
            # malloc for vtable, NUM_APIS APIs * 4 byte addresses
            @vtable = 0.chr * 4*NUM_APIS
            # Copy *vtable from interface
            Memcpy.call(lpVtbl,@interface_ptr,4)
            # Copy vtable contents into @vtable
            Memcpy.call(@vtable,lpVtbl.unpack('L').first,4*NUM_APIS)
            # Unpack into an array of addresses
            @vtable=@vtable.unpack('L*')
            # These are autogenerated from dbgeng.h and may contain errors!
            @api_dispatch_table={
                :QueryInterface=>Win32::API::Function.new(@vtable[0], 'PPP', 'L'),
                :AddRef=>Win32::API::Function.new(@vtable[1], 'P', 'L'),
                :Release=>Win32::API::Function.new(@vtable[2], 'P', 'L'),
                :GetThreadContext=>Win32::API::Function.new(@vtable[3], 'PPL', 'L'),
                :SetThreadContext=>Win32::API::Function.new(@vtable[4], 'PPL', 'L')
            }            
        end

        def ptr
            @interface_ptr
        end

        def method_missing( meth, *args )
            raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
            @api_dispatch_table[meth].call( @interface_ptr, *args )
        end
    end

    class DebugDataSpaces
        NUM_APIS= 23
        # Local Constants
        def initialize( parent )
            # Get a pointer to the interface
            p = 0.chr*4
            parent.QueryInterface(IIDS[self.class.to_s], p)
            @interface_ptr = p.unpack('L').first
            raise "#{self.class}: Unable to get interface pointer!" if @interface_ptr.zero?
            # *vtable
            lpVtbl = 0.chr * 4
            # malloc for vtable, NUM_APIS APIs * 4 byte addresses
            @vtable = 0.chr * 4*NUM_APIS
            # Copy *vtable from interface
            Memcpy.call(lpVtbl,@interface_ptr,4)
            # Copy vtable contents into @vtable
            Memcpy.call(@vtable,lpVtbl.unpack('L').first,4*NUM_APIS)
            # Unpack into an array of addresses
            @vtable=@vtable.unpack('L*')
            # These are autogenerated from dbgeng.h and may contain errors!
            @api_dispatch_table={
                :QueryInterface=>Win32::API::Function.new(@vtable[0], 'PPP', 'L'),
                :AddRef=>Win32::API::Function.new(@vtable[1], 'P', 'L'),
                :Release=>Win32::API::Function.new(@vtable[2], 'P', 'L'),
                :ReadVirtual=>Win32::API::Function.new(@vtable[3], 'PLLPLP', 'L'),
                :WriteVirtual=>Win32::API::Function.new(@vtable[4], 'PLLPLP', 'L'),
                :SearchVirtual=>Win32::API::Function.new(@vtable[5], 'PLLLLPLLP', 'L'),
                :ReadVirtualUncached=>Win32::API::Function.new(@vtable[6], 'PLLPLP', 'L'),
                :WriteVirtualUncached=>Win32::API::Function.new(@vtable[7], 'PLLPLP', 'L'),
                :ReadPointersVirtual=>Win32::API::Function.new(@vtable[8], 'PLLLP', 'L'),
                :WritePointersVirtual=>Win32::API::Function.new(@vtable[9], 'PLLLP', 'L'),
                :ReadPhysical=>Win32::API::Function.new(@vtable[10], 'PLLPLP', 'L'),
                :WritePhysical=>Win32::API::Function.new(@vtable[11], 'PLLPLP', 'L'),
                :ReadControl=>Win32::API::Function.new(@vtable[12], 'PLLLPLP', 'L'),
                :WriteControl=>Win32::API::Function.new(@vtable[13], 'PLLLPLP', 'L'),
                :ReadIo=>Win32::API::Function.new(@vtable[14], 'PLLLLLPLP', 'L'),
                :WriteIo=>Win32::API::Function.new(@vtable[15], 'PLLLLLPLP', 'L'),
                :ReadMsr=>Win32::API::Function.new(@vtable[16], 'PLP', 'L'),
                :WriteMsr=>Win32::API::Function.new(@vtable[17], 'PLLL', 'L'),
                :ReadBusData=>Win32::API::Function.new(@vtable[18], 'PLLLLPLP', 'L'),
                :WriteBusData=>Win32::API::Function.new(@vtable[19], 'PLLLLPLP', 'L'),
                :CheckLowMemory=>Win32::API::Function.new(@vtable[20], 'P', 'L'),
                :ReadDebuggerData=>Win32::API::Function.new(@vtable[21], 'PLPLP', 'L'),
                :ReadProcessorSystemData=>Win32::API::Function.new(@vtable[22], 'PLLPLP', 'L')
            }            
        end

        def ptr
            @interface_ptr
        end

        def method_missing( meth, *args )
            raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
            @api_dispatch_table[meth].call( @interface_ptr, *args )
        end
    end

    class DebugSymbols
        NUM_APIS=52
        # Local Constants
        DEBUG_MODULE_LOADED=0x00000000
        DEBUG_MODULE_UNLOADED=0x00000001
        DEBUG_MODULE_USER_MODE=0x00000002
        DEBUG_MODULE_EXE_MODULE=0x00000004
        DEBUG_MODULE_EXPLICIT=0x00000008
        DEBUG_MODULE_SECONDARY=0x00000010
        DEBUG_MODULE_SYNTHETIC=0x00000020
        DEBUG_MODULE_SYM_BAD_CHECKSUM=0x00010000
        DEBUG_SYMTYPE_NONE=0
        DEBUG_SYMTYPE_COFF=1
        DEBUG_SYMTYPE_CODEVIEW=2
        DEBUG_SYMTYPE_PDB=3
        DEBUG_SYMTYPE_EXPORT=4
        DEBUG_SYMTYPE_DEFERRED=5
        DEBUG_SYMTYPE_SYM=6
        DEBUG_SYMTYPE_DIA=7
        DEBUG_SCOPE_GROUP_ARGUMENTS=0x00000001
        DEBUG_SCOPE_GROUP_LOCALS=0x00000002
        DEBUG_SCOPE_GROUP_ALL=0x00000003
        DEBUG_OUTTYPE_DEFAULT=0x00000000
        DEBUG_OUTTYPE_NO_INDENT=0x00000001
        DEBUG_OUTTYPE_NO_OFFSET=0x00000002
        DEBUG_OUTTYPE_VERBOSE=0x00000004
        DEBUG_OUTTYPE_COMPACT_OUTPUT=0x00000008
        DEBUG_OUTTYPE_ADDRESS_OF_FIELD=0x00010000
        DEBUG_OUTTYPE_ADDRESS_AT_END=0x00020000
        DEBUG_OUTTYPE_BLOCK_RECURSE=0x00200000
        DEBUG_FIND_SOURCE_DEFAULT=0x00000000
        DEBUG_FIND_SOURCE_FULL_PATH=0x00000001
        DEBUG_FIND_SOURCE_BEST_MATCH=0x00000002
        DEBUG_FIND_SOURCE_NO_SRCSRV=0x00000004
        DEBUG_FIND_SOURCE_TOKEN_LOOKUP=0x00000008
        DEBUG_INVALID_OFFSET=0xffffffffffffffff
        MODULE_ORDERS_MASK=0xF0000000
        MODULE_ORDERS_LOADTIME=0x10000000
        MODULE_ORDERS_MODULENAME=0x20000000

        def initialize( parent )
            # Get a pointer to the interface
            p = 0.chr*4
            parent.QueryInterface(IIDS[self.class.to_s], p)
            @interface_ptr = p.unpack('L').first
            raise "#{self.class}: Unable to get interface pointer!" if @interface_ptr.zero?
            # *vtable
            lpVtbl = 0.chr * 4
            # malloc for vtable, NUM_APIS APIs * 4 byte addresses
            @vtable = 0.chr * 4*NUM_APIS
            # Copy *vtable from interface
            Memcpy.call(lpVtbl,@interface_ptr,4)
            # Copy vtable contents into @vtable
            Memcpy.call(@vtable,lpVtbl.unpack('L').first,4*NUM_APIS)
            # Unpack into an array of addresses
            @vtable=@vtable.unpack('L*')
            # These are autogenerated from dbgeng.h and may contain errors!
            @api_dispatch_table={
                :QueryInterface=>Win32::API::Function.new(@vtable[0], 'PPP', 'L'),
                :AddRef=>Win32::API::Function.new(@vtable[1], 'P', 'L'),
                :Release=>Win32::API::Function.new(@vtable[2], 'P', 'L'),
                :GetSymbolOptions=>Win32::API::Function.new(@vtable[3], 'PP', 'L'),
                :AddSymbolOptions=>Win32::API::Function.new(@vtable[4], 'PL', 'L'),
                :RemoveSymbolOptions=>Win32::API::Function.new(@vtable[5], 'PL', 'L'),
                :SetSymbolOptions=>Win32::API::Function.new(@vtable[6], 'PL', 'L'),
                :GetNameByOffset=>Win32::API::Function.new(@vtable[7], 'PLLPLPP', 'L'),
                :GetOffsetByName=>Win32::API::Function.new(@vtable[8], 'PPP', 'L'),
                :GetNearNameByOffset=>Win32::API::Function.new(@vtable[9], 'PLLLPLPP', 'L'),
                :GetLineByOffset=>Win32::API::Function.new(@vtable[10], 'PLLPPLPP', 'L'),
                :GetOffsetByLine=>Win32::API::Function.new(@vtable[11], 'PLPP', 'L'),
                :GetNumberModules=>Win32::API::Function.new(@vtable[12], 'PPP', 'L'),
                :GetModuleByIndex=>Win32::API::Function.new(@vtable[13], 'PLP', 'L'),
                :GetModuleByModuleName=>Win32::API::Function.new(@vtable[14], 'PPLPP', 'L'),
                :GetModuleByOffset=>Win32::API::Function.new(@vtable[15], 'PLLLPP', 'L'),
                :GetModuleNames=>Win32::API::Function.new(@vtable[16], 'PLLLPLPPLPPLP', 'L'),
                :GetModuleParameters=>Win32::API::Function.new(@vtable[17], 'PLPLP', 'L'),
                :GetSymbolModule=>Win32::API::Function.new(@vtable[18], 'PPP', 'L'),
                :GetTypeName=>Win32::API::Function.new(@vtable[19], 'PLLLPLP', 'L'),
                :GetTypeId=>Win32::API::Function.new(@vtable[20], 'PLLPP', 'L'),
                :GetTypeSize=>Win32::API::Function.new(@vtable[21], 'PLLLP', 'L'),
                :GetFieldOffset=>Win32::API::Function.new(@vtable[22], 'PLLLPP', 'L'),
                :GetSymbolTypeId=>Win32::API::Function.new(@vtable[23], 'PPPP', 'L'),
                :GetOffsetTypeId=>Win32::API::Function.new(@vtable[24], 'PLLPP', 'L'),
                :ReadTypedDataVirtual=>Win32::API::Function.new(@vtable[25], 'PLLLLLPLP', 'L'),
                :WriteTypedDataVirtual=>Win32::API::Function.new(@vtable[26], 'PLLLLLPLP', 'L'),
                :OutputTypedDataVirtual=>Win32::API::Function.new(@vtable[27], 'PLLLLLLL', 'L'),
                :ReadTypedDataPhysical=>Win32::API::Function.new(@vtable[28], 'PLLLLLPLP', 'L'),
                :WriteTypedDataPhysical=>Win32::API::Function.new(@vtable[29], 'PLLLLLPLP', 'L'),
                :OutputTypedDataPhysical=>Win32::API::Function.new(@vtable[30], 'PLLLLLLL', 'L'),
                :GetScope=>Win32::API::Function.new(@vtable[31], 'PPPPL', 'L'),
                :SetScope=>Win32::API::Function.new(@vtable[32], 'PLLPPL', 'L'),
                :ResetScope=>Win32::API::Function.new(@vtable[33], 'P', 'L'),
                :GetScopeSymbolGroup=>Win32::API::Function.new(@vtable[34], 'PLPP', 'L'),
                :CreateSymbolGroup=>Win32::API::Function.new(@vtable[35], 'PP', 'L'),
                :StartSymbolMatch=>Win32::API::Function.new(@vtable[36], 'PPP', 'L'),
                :GetNextSymbolMatch=>Win32::API::Function.new(@vtable[37], 'PLLPLPP', 'L'),
                :EndSymbolMatch=>Win32::API::Function.new(@vtable[38], 'PLL', 'L'),
                :Reload=>Win32::API::Function.new(@vtable[39], 'PP', 'L'),
                :GetSymbolPath=>Win32::API::Function.new(@vtable[40], 'PPLP', 'L'),
                :SetSymbolPath=>Win32::API::Function.new(@vtable[41], 'PP', 'L'),
                :AppendSymbolPath=>Win32::API::Function.new(@vtable[42], 'PP', 'L'),
                :GetImagePath=>Win32::API::Function.new(@vtable[43], 'PPLP', 'L'),
                :SetImagePath=>Win32::API::Function.new(@vtable[44], 'PP', 'L'),
                :AppendImagePath=>Win32::API::Function.new(@vtable[45], 'PP', 'L'),
                :GetSourcePath=>Win32::API::Function.new(@vtable[46], 'PPLP', 'L'),
                :GetSourcePathElement=>Win32::API::Function.new(@vtable[47], 'PLPLP', 'L'),
                :SetSourcePath=>Win32::API::Function.new(@vtable[48], 'PP', 'L'),
                :AppendSourcePath=>Win32::API::Function.new(@vtable[49], 'PP', 'L'),
                :FindSourceFile=>Win32::API::Function.new(@vtable[50], 'PLPLPPLP', 'L'),
                :GetSourceFileLineOffsets=>Win32::API::Function.new(@vtable[51], 'PPPLP', 'L')
            }            
        end

        def ptr
            @interface_ptr
        end

        def method_missing( meth, *args )
            raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
            @api_dispatch_table[meth].call( @interface_ptr, *args )
        end
    end

    class DebugSymbols2
        NUM_APIS=60
        # Local Constants
        DEBUG_MODNAME_IMAGE=0x00000000
        DEBUG_MODNAME_MODULE=0x00000001
        DEBUG_MODNAME_LOADED_IMAGE=0x00000002
        DEBUG_MODNAME_SYMBOL_FILE=0x00000003
        DEBUG_MODNAME_MAPPED_IMAGE=0x00000004
        DEBUG_TYPEOPTS_UNICODE_DISPLAY=0x00000001
        DEBUG_TYPEOPTS_LONGSTATUS_DISPLAY=0x00000002
        DEBUG_TYPEOPTS_FORCERADIX_OUTPUT=0x00000004
        DEBUG_TYPEOPTS_MATCH_MAXSIZE=0x00000008

        def initialize( parent )
            # Get a pointer to the interface
            p = 0.chr*4
            parent.QueryInterface(IIDS[self.class.to_s], p)
            @interface_ptr = p.unpack('L').first
            raise "#{self.class}: Unable to get interface pointer!" if @interface_ptr.zero?
            # *vtable
            lpVtbl = 0.chr * 4
            # malloc for vtable, NUM_APIS APIs * 4 byte addresses
            @vtable = 0.chr * 4*NUM_APIS
            # Copy *vtable from interface
            Memcpy.call(lpVtbl,@interface_ptr,4)
            # Copy vtable contents into @vtable
            Memcpy.call(@vtable,lpVtbl.unpack('L').first,4*NUM_APIS)
            # Unpack into an array of addresses
            @vtable=@vtable.unpack('L*')
            # These are autogenerated from dbgeng.h and may contain errors!
            @api_dispatch_table={
                :QueryInterface=>Win32::API::Function.new(@vtable[0], 'PPP', 'L'),
                :AddRef=>Win32::API::Function.new(@vtable[1], 'P', 'L'),
                :Release=>Win32::API::Function.new(@vtable[2], 'P', 'L'),
                :GetSymbolOptions=>Win32::API::Function.new(@vtable[3], 'PP', 'L'),
                :AddSymbolOptions=>Win32::API::Function.new(@vtable[4], 'PL', 'L'),
                :RemoveSymbolOptions=>Win32::API::Function.new(@vtable[5], 'PL', 'L'),
                :SetSymbolOptions=>Win32::API::Function.new(@vtable[6], 'PL', 'L'),
                :GetNameByOffset=>Win32::API::Function.new(@vtable[7], 'PLLPLPP', 'L'),
                :GetOffsetByName=>Win32::API::Function.new(@vtable[8], 'PPP', 'L'),
                :GetNearNameByOffset=>Win32::API::Function.new(@vtable[9], 'PLLLPLPP', 'L'),
                :GetLineByOffset=>Win32::API::Function.new(@vtable[10], 'PLLPPLPP', 'L'),
                :GetOffsetByLine=>Win32::API::Function.new(@vtable[11], 'PLPP', 'L'),
                :GetNumberModules=>Win32::API::Function.new(@vtable[12], 'PPP', 'L'),
                :GetModuleByIndex=>Win32::API::Function.new(@vtable[13], 'PLP', 'L'),
                :GetModuleByModuleName=>Win32::API::Function.new(@vtable[14], 'PPLPP', 'L'),
                :GetModuleByOffset=>Win32::API::Function.new(@vtable[15], 'PLLLPP', 'L'),
                :GetModuleNames=>Win32::API::Function.new(@vtable[16], 'PLLLPLPPLPPLP', 'L'),
                :GetModuleParameters=>Win32::API::Function.new(@vtable[17], 'PLPLP', 'L'),
                :GetSymbolModule=>Win32::API::Function.new(@vtable[18], 'PPP', 'L'),
                :GetTypeName=>Win32::API::Function.new(@vtable[19], 'PLLLPLP', 'L'),
                :GetTypeId=>Win32::API::Function.new(@vtable[20], 'PLLPP', 'L'),
                :GetTypeSize=>Win32::API::Function.new(@vtable[21], 'PLLLP', 'L'),
                :GetFieldOffset=>Win32::API::Function.new(@vtable[22], 'PLLLPP', 'L'),
                :GetSymbolTypeId=>Win32::API::Function.new(@vtable[23], 'PPPP', 'L'),
                :GetOffsetTypeId=>Win32::API::Function.new(@vtable[24], 'PLLPP', 'L'),
                :ReadTypedDataVirtual=>Win32::API::Function.new(@vtable[25], 'PLLLLLPLP', 'L'),
                :WriteTypedDataVirtual=>Win32::API::Function.new(@vtable[26], 'PLLLLLPLP', 'L'),
                :OutputTypedDataVirtual=>Win32::API::Function.new(@vtable[27], 'PLLLLLLL', 'L'),
                :ReadTypedDataPhysical=>Win32::API::Function.new(@vtable[28], 'PLLLLLPLP', 'L'),
                :WriteTypedDataPhysical=>Win32::API::Function.new(@vtable[29], 'PLLLLLPLP', 'L'),
                :OutputTypedDataPhysical=>Win32::API::Function.new(@vtable[30], 'PLLLLLLL', 'L'),
                :GetScope=>Win32::API::Function.new(@vtable[31], 'PPPPL', 'L'),
                :SetScope=>Win32::API::Function.new(@vtable[32], 'PLLPPL', 'L'),
                :ResetScope=>Win32::API::Function.new(@vtable[33], 'P', 'L'),
                :GetScopeSymbolGroup=>Win32::API::Function.new(@vtable[34], 'PLPP', 'L'),
                :CreateSymbolGroup=>Win32::API::Function.new(@vtable[35], 'PP', 'L'),
                :StartSymbolMatch=>Win32::API::Function.new(@vtable[36], 'PPP', 'L'),
                :GetNextSymbolMatch=>Win32::API::Function.new(@vtable[37], 'PLLPLPP', 'L'),
                :EndSymbolMatch=>Win32::API::Function.new(@vtable[38], 'PLL', 'L'),
                :Reload=>Win32::API::Function.new(@vtable[39], 'PP', 'L'),
                :GetSymbolPath=>Win32::API::Function.new(@vtable[40], 'PPLP', 'L'),
                :SetSymbolPath=>Win32::API::Function.new(@vtable[41], 'PP', 'L'),
                :AppendSymbolPath=>Win32::API::Function.new(@vtable[42], 'PP', 'L'),
                :GetImagePath=>Win32::API::Function.new(@vtable[43], 'PPLP', 'L'),
                :SetImagePath=>Win32::API::Function.new(@vtable[44], 'PP', 'L'),
                :AppendImagePath=>Win32::API::Function.new(@vtable[45], 'PP', 'L'),
                :GetSourcePath=>Win32::API::Function.new(@vtable[46], 'PPLP', 'L'),
                :GetSourcePathElement=>Win32::API::Function.new(@vtable[47], 'PLPLP', 'L'),
                :SetSourcePath=>Win32::API::Function.new(@vtable[48], 'PP', 'L'),
                :AppendSourcePath=>Win32::API::Function.new(@vtable[49], 'PP', 'L'),
                :FindSourceFile=>Win32::API::Function.new(@vtable[50], 'PLPLPPLP', 'L'),
                :GetSourceFileLineOffsets=>Win32::API::Function.new(@vtable[51], 'PPPLP', 'L'),
                :GetModuleVersionInformation=>Win32::API::Function.new(@vtable[52], 'PLLLPPLP', 'L'),
                :GetModuleNameString=>Win32::API::Function.new(@vtable[53], 'PLLLLPLP', 'L'),
                :GetConstantName=>Win32::API::Function.new(@vtable[54], 'PLLLLLPLP', 'L'),
                :GetFieldName=>Win32::API::Function.new(@vtable[55], 'PLLLLPLP', 'L'),
                :GetTypeOptions=>Win32::API::Function.new(@vtable[56], 'PP', 'L'),
                :AddTypeOptions=>Win32::API::Function.new(@vtable[57], 'PL', 'L'),
                :RemoveTypeOptions=>Win32::API::Function.new(@vtable[58], 'PL', 'L'),
                :SetTypeOptions=>Win32::API::Function.new(@vtable[59], 'PL', 'L')
            }            
        end

        def ptr
            @interface_ptr
        end

        def method_missing( meth, *args )
            raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
            @api_dispatch_table[meth].call( @interface_ptr, *args )
        end
    end

    class DebugSystemObjects
        NUM_APIS=32
        # Local Constants
        def initialize( parent )
            # Get a pointer to the interface
            p = 0.chr*4
            parent.QueryInterface(IIDS[self.class.to_s], p)
            @interface_ptr = p.unpack('L').first
            raise "#{self.class}: Unable to get interface pointer!" if @interface_ptr.zero?
            # *vtable
            lpVtbl = 0.chr * 4
            # malloc for vtable, NUM_APIS * 4 byte addresses
            @vtable = 0.chr * 4*NUM_APIS
            # Copy *vtable from interface
            Memcpy.call(lpVtbl,@interface_ptr,4)
            # Copy vtable contents into @vtable
            Memcpy.call(@vtable,lpVtbl.unpack('L').first,4*NUM_APIS)
            # Unpack into an array of addresses
            @vtable=@vtable.unpack('L*')
            # These are autogenerated from dbgeng.h and may contain errors!
            @api_dispatch_table={
                :QueryInterface=>Win32::API::Function.new(@vtable[0], 'PPP', 'L'),
                :AddRef=>Win32::API::Function.new(@vtable[1], 'P', 'L'),
                :Release=>Win32::API::Function.new(@vtable[2], 'P', 'L'),
                :GetEventThread=>Win32::API::Function.new(@vtable[3], 'PP', 'L'),
                :GetEventProcess=>Win32::API::Function.new(@vtable[4], 'PP', 'L'),
                :GetCurrentThreadId=>Win32::API::Function.new(@vtable[5], 'PP', 'L'),
                :SetCurrentThreadId=>Win32::API::Function.new(@vtable[6], 'PL', 'L'),
                :GetCurrentProcessId=>Win32::API::Function.new(@vtable[7], 'PP', 'L'),
                :SetCurrentProcessId=>Win32::API::Function.new(@vtable[8], 'PL', 'L'),
                :GetNumberThreads=>Win32::API::Function.new(@vtable[9], 'PP', 'L'),
                :GetTotalNumberThreads=>Win32::API::Function.new(@vtable[10], 'PPP', 'L'),
                :GetThreadIdsByIndex=>Win32::API::Function.new(@vtable[11], 'PLLPP', 'L'),
                :GetThreadIdByProcessor=>Win32::API::Function.new(@vtable[12], 'PLP', 'L'),
                :GetCurrentThreadDataOffset=>Win32::API::Function.new(@vtable[13], 'PP', 'L'),
                :GetThreadIdByDataOffset=>Win32::API::Function.new(@vtable[14], 'PLLP', 'L'),
                :GetCurrentThreadTeb=>Win32::API::Function.new(@vtable[15], 'PP', 'L'),
                :GetThreadIdByTeb=>Win32::API::Function.new(@vtable[16], 'PLLP', 'L'),
                :GetCurrentThreadSystemId=>Win32::API::Function.new(@vtable[17], 'PP', 'L'),
                :GetThreadIdBySystemId=>Win32::API::Function.new(@vtable[18], 'PLP', 'L'),
                :GetCurrentThreadHandle=>Win32::API::Function.new(@vtable[19], 'PP', 'L'),
                :GetThreadIdByHandle=>Win32::API::Function.new(@vtable[20], 'PLLP', 'L'),
                :GetNumberProcesses=>Win32::API::Function.new(@vtable[21], 'PP', 'L'),
                :GetProcessIdsByIndex=>Win32::API::Function.new(@vtable[22], 'PLLPP', 'L'),
                :GetCurrentProcessDataOffset=>Win32::API::Function.new(@vtable[23], 'PP', 'L'),
                :GetProcessIdByDataOffset=>Win32::API::Function.new(@vtable[24], 'PLLP', 'L'),
                :GetCurrentProcessPeb=>Win32::API::Function.new(@vtable[25], 'PP', 'L'),
                :GetProcessIdByPeb=>Win32::API::Function.new(@vtable[26], 'PLLP', 'L'),
                :GetCurrentProcessSystemId=>Win32::API::Function.new(@vtable[27], 'PP', 'L'),
                :GetProcessIdBySystemId=>Win32::API::Function.new(@vtable[28], 'PLP', 'L'),
                :GetCurrentProcessHandle=>Win32::API::Function.new(@vtable[29], 'PP', 'L'),
                :GetProcessIdByHandle=>Win32::API::Function.new(@vtable[30], 'PLLP', 'L'),
                :GetCurrentProcessExecutableName=>Win32::API::Function.new(@vtable[31], 'PPLP', 'L')
            }            
        end

        def ptr
            @interface_ptr
        end

        def method_missing( meth, *args )
            raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
            @api_dispatch_table[meth].call( @interface_ptr, *args )
        end
    end

    class DebugAdvanced3
        NUM_APIS=13
        # Local Constants
        DEBUG_GET_TEXT_COMPLETIONS_NO_DOT_COMMANDS=0x00000001
        DEBUG_GET_TEXT_COMPLETIONS_NO_EXTENSION_COMMANDS=0x00000002
        DEBUG_GET_TEXT_COMPLETIONS_NO_SYMBOLS=0x00000004
        DEBUG_GET_TEXT_COMPLETIONS_IS_DOT_COMMAND=0x00000001
        DEBUG_GET_TEXT_COMPLETIONS_IS_EXTENSION_COMMAND=0x00000002
        DEBUG_GET_TEXT_COMPLETIONS_IS_SYMBOL=0x00000004
        DEBUG_REQUEST_SOURCE_PATH_HAS_SOURCE_SERVER=0
        DEBUG_REQUEST_TARGET_EXCEPTION_CONTEXT=1
        DEBUG_REQUEST_TARGET_EXCEPTION_THREAD=2
        DEBUG_REQUEST_TARGET_EXCEPTION_RECORD=3
        DEBUG_REQUEST_GET_ADDITIONAL_CREATE_OPTIONS=4
        DEBUG_REQUEST_SET_ADDITIONAL_CREATE_OPTIONS=5
        DEBUG_REQUEST_GET_WIN32_MAJOR_MINOR_VERSIONS=6
        DEBUG_REQUEST_READ_USER_MINIDUMP_STREAM=7
        DEBUG_REQUEST_TARGET_CAN_DETACH=8
        DEBUG_REQUEST_SET_LOCAL_IMPLICIT_COMMAND_LINE=9
        DEBUG_REQUEST_GET_CAPTURED_EVENT_CODE_OFFSET=10
        DEBUG_REQUEST_READ_CAPTURED_EVENT_CODE_STREAM=11
        DEBUG_REQUEST_EXT_TYPED_DATA_ANSI=12
        DEBUG_REQUEST_GET_EXTENSION_SEARCH_PATH_WIDE=13
        DEBUG_REQUEST_GET_TEXT_COMPLETIONS_WIDE=14
        DEBUG_REQUEST_GET_CACHED_SYMBOL_INFO=15
        DEBUG_REQUEST_ADD_CACHED_SYMBOL_INFO=16
        DEBUG_REQUEST_REMOVE_CACHED_SYMBOL_INFO=17
        DEBUG_REQUEST_GET_TEXT_COMPLETIONS_ANSI=18
        DEBUG_REQUEST_CURRENT_OUTPUT_CALLBACKS_ARE_DML_AWARE=19
        DEBUG_REQUEST_GET_OFFSET_UNWIND_INFORMATION=20
        DEBUG_REQUEST_GET_DUMP_HEADER=21
        DEBUG_REQUEST_SET_DUMP_HEADER=22
        DEBUG_REQUEST_MIDORI=23
        DEBUG_REQUEST_PROCESS_DESCRIPTORS=24
        DEBUG_REQUEST_MISC_INFORMATION=25
        DEBUG_REQUEST_OPEN_PROCESS_TOKEN=26
        DEBUG_REQUEST_OPEN_THREAD_TOKEN=27
        DEBUG_REQUEST_DUPLICATE_TOKEN=28
        DEBUG_REQUEST_QUERY_INFO_TOKEN=29
        DEBUG_REQUEST_CLOSE_TOKEN=30
        DEBUG_SRCFILE_SYMBOL_TOKEN=0
        DEBUG_SRCFILE_SYMBOL_TOKEN_SOURCE_COMMAND_WIDE=1
        DEBUG_SYMINFO_BREAKPOINT_SOURCE_LINE=0
        DEBUG_SYMINFO_IMAGEHLP_MODULEW64=1
        DEBUG_SYMINFO_GET_SYMBOL_NAME_BY_OFFSET_AND_TAG_WIDE=2
        DEBUG_SYMINFO_GET_MODULE_SYMBOL_NAMES_AND_OFFSETS=3
        DEBUG_SYSOBJINFO_THREAD_BASIC_INFORMATION=0
        DEBUG_SYSOBJINFO_THREAD_NAME_WIDE=1
        DEBUG_SYSOBJINFO_CURRENT_PROCESS_COOKIE=2
        DEBUG_TBINFO_EXIT_STATUS=0x00000001
        DEBUG_TBINFO_PRIORITY_CLASS=0x00000002
        DEBUG_TBINFO_PRIORITY=0x00000004
        DEBUG_TBINFO_TIMES=0x00000008
        DEBUG_TBINFO_START_OFFSET=0x00000010
        DEBUG_TBINFO_AFFINITY=0x00000020
        DEBUG_TBINFO_ALL=0x0000003f

        def initialize( parent )
            # Get a pointer to the interface
            p = 0.chr*4
            parent.QueryInterface(IIDS[self.class.to_s], p)
            @interface_ptr = p.unpack('L').first
            raise "#{self.class}: Unable to get interface pointer!" if @interface_ptr.zero?
            # *vtable
            lpVtbl = 0.chr * 4
            # malloc for vtable, NUM_APIS APIs * 4 byte addresses
            @vtable = 0.chr * 4*NUM_APIS
            # Copy *vtable from interface
            Memcpy.call(lpVtbl,@interface_ptr,4)
            # Copy vtable contents into @vtable
            Memcpy.call(@vtable,lpVtbl.unpack('L').first,4*NUM_APIS)
            # Unpack into an array of addresses
            @vtable=@vtable.unpack('L*')
            # These are autogenerated from dbgeng.h and may contain errors!
            @api_dispatch_table={
                :QueryInterface=>Win32::API::Function.new(@vtable[0], 'PPP', 'L'),
                :AddRef=>Win32::API::Function.new(@vtable[1], 'P', 'L'),
                :Release=>Win32::API::Function.new(@vtable[2], 'P', 'L'),
                :GetThreadContext=>Win32::API::Function.new(@vtable[3], 'PPL', 'L'),
                :SetThreadContext=>Win32::API::Function.new(@vtable[4], 'PPL', 'L'),
                :Request=>Win32::API::Function.new(@vtable[5], 'PLPLPLP', 'L'),
                :GetSourceFileInformation=>Win32::API::Function.new(@vtable[6], 'PLPLLLPLP', 'L'),
                :FindSourceFileAndToken=>Win32::API::Function.new(@vtable[7], 'PLLLPLPLPPLP', 'L'),
                :GetSymbolInformation=>Win32::API::Function.new(@vtable[8], 'PLLLLPLPPLP', 'L'),
                :GetSystemObjectInformation=>Win32::API::Function.new(@vtable[9], 'PLLLLPLP', 'L'),
                :GetSourceFileInformationWide=>Win32::API::Function.new(@vtable[10], 'PLPLLLPLP', 'L'),
                :FindSourceFileAndTokenWide=>Win32::API::Function.new(@vtable[11], 'PLLLPLPLPPLP', 'L'),
                :GetSymbolInformationWide=>Win32::API::Function.new(@vtable[12], 'PLLLLPLPPLP', 'L')
            }            
        end

        def ptr
            @interface_ptr
        end

        def method_missing( meth, *args )
            raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
            @api_dispatch_table[meth].call( @interface_ptr, *args )
        end
    end
end
