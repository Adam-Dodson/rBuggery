# LazyBreakpoint can be used anywhere the normal breakpoint classes in Raw are
# used. There are two advantages - firstly, the FFI::Pointers and
# FFI::Functions for the COM methods are only created on use, which hopefully
# makes it faster to create a LazyBreakpoint, and secondly the interface
# pointer can be reset, so you can create one ruby-level LazyBreakpoint and
# just reset its pointer in the breakpoint callback, saving a ruby-level
# object creation as well.
#
# For example you could start your callback like this:
#   bp_proc = lambda {|args|
#
#     begin
#
#       if @bp
#         @bp.ptr = args[:breakpoint]
#       else
#         @bp = LazyBreakpoint.new args[:breakpoint]
#       end
#       # ... use @bp here ...
#
# Author: Ben Nagy
# Copyright: Copyright (c) Ben Nagy, 2012 - 2014.
# License: BSD Style, see LICENSE file for details

require 'ffi'
require 'win32/wintypes'

module Buggery
  module Structs

    class LazyBreakpoint

      # This class must be created from a pointer

      NUM_APIS = 29

      include Win32::WinTypes

      def initialize ptr

        @interface_ptr = ptr
        @vtable = @interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS )
        @lazy_vtable = Hash.new {|h,k|
          h[k] = FFI::Pointer.new( @vtable[k])
        }

        # These are autogenerated from dbgeng.h and may contain errors!
        @api_dispatch_table = {
          # QueryInterface(THIS_ In_(InterfaceId) Out_(Interface))
          :QueryInterface => [ HRESULT, [THIS_, REFIID, PVOID], 0, :convention=>:stdcall ],
          # AddRef(THIS)
          :AddRef => [ HRESULT, [THIS_], 1, :convention=>:stdcall ],
          # Release(THIS)
          :Release => [ HRESULT, [THIS_], 2, :convention=>:stdcall ],
          # GetId(THIS_ Out_(Id))
          :GetId => [ HRESULT, [THIS_, PULONG], 3, :convention=>:stdcall ],
          # GetType(THIS_ Out_(BreakType) Out_(ProcType))
          :GetType => [ HRESULT, [THIS_, PULONG, PULONG], 4, :convention=>:stdcall ],
          # GetAdder(THIS_ Out_(Adder))
          :GetAdder => [ HRESULT, [THIS_, PDEBUG_CLIENT], 5, :convention=>:stdcall ],
          # GetFlags(THIS_ Out_(Flags))
          :GetFlags => [ HRESULT, [THIS_, PULONG], 6, :convention=>:stdcall ],
          # AddFlags(THIS_ In_(Flags))
          :AddFlags => [ HRESULT, [THIS_, ULONG], 7, :convention=>:stdcall ],
          # RemoveFlags(THIS_ In_(Flags))
          :RemoveFlags => [ HRESULT, [THIS_, ULONG], 8, :convention=>:stdcall ],
          # SetFlags(THIS_ In_(Flags))
          :SetFlags => [ HRESULT, [THIS_, ULONG], 9, :convention=>:stdcall ],
          # GetOffset(THIS_ Out_(Offset))
          :GetOffset => [ HRESULT, [THIS_, PULONG64], 10, :convention=>:stdcall ],
          # SetOffset(THIS_ In_(Offset))
          :SetOffset => [ HRESULT, [THIS_, ULONG64], 11, :convention=>:stdcall ],
          # GetDataParameters(THIS_ Out_(Size) Out_(AccessType))
          :GetDataParameters => [ HRESULT, [THIS_, PULONG, PULONG], 12, :convention=>:stdcall ],
          # SetDataParameters(THIS_ In_(Size) In_(AccessType))
          :SetDataParameters => [ HRESULT, [THIS_, ULONG, ULONG], 13, :convention=>:stdcall ],
          # GetPassCount(THIS_ Out_(Count))
          :GetPassCount => [ HRESULT, [THIS_, PULONG], 14, :convention=>:stdcall ],
          # SetPassCount(THIS_ In_(Count))
          :SetPassCount => [ HRESULT, [THIS_, ULONG], 15, :convention=>:stdcall ],
          # GetCurrentPassCount(THIS_ Out_(Count))
          :GetCurrentPassCount => [ HRESULT, [THIS_, PULONG], 16, :convention=>:stdcall ],
          # GetMatchThreadId(THIS_ Out_(Id))
          :GetMatchThreadId => [ HRESULT, [THIS_, PULONG], 17, :convention=>:stdcall ],
          # SetMatchThreadId(THIS_ In_(Thread))
          :SetMatchThreadId => [ HRESULT, [THIS_, ULONG], 18, :convention=>:stdcall ],
          # GetCommand(THIS_ Out_writes_opt_(BufferSize)(Buffer) In_(BufferSize) Out_opt_(CommandSize))
          :GetCommand => [ HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], 19, :convention=>:stdcall ],
          # SetCommand(THIS_ In_(Command))
          :SetCommand => [ HRESULT, [THIS_, PCSTR], 20, :convention=>:stdcall ],
          # GetOffsetExpression(THIS_ Out_writes_opt_(BufferSize)(Buffer) In_(BufferSize) Out_opt_(ExpressionSize))
          :GetOffsetExpression => [ HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], 21, :convention=>:stdcall ],
          # SetOffsetExpression(THIS_ In_(Expression))
          :SetOffsetExpression => [ HRESULT, [THIS_, PCSTR], 22, :convention=>:stdcall ],
          # GetParameters(THIS_ Out_(Params))
          :GetParameters => [ HRESULT, [THIS_, Structs::DebugBreakpointParameters.ptr], 23, :convention=>:stdcall ],
          # GetCommandWide(THIS_ Out_writes_opt_(BufferSize)(Buffer) In_(BufferSize) Out_opt_(CommandSize))
          :GetCommandWide => [ HRESULT, [THIS_, PWSTR_OUT, ULONG, PULONG], 24, :convention=>:stdcall ],
          # SetCommandWide(THIS_ In_(Command))
          :SetCommandWide => [ HRESULT, [THIS_, PCWSTR], 25, :convention=>:stdcall ],
          # GetOffsetExpressionWide(THIS_ Out_writes_opt_(BufferSize)(Buffer) In_(BufferSize) Out_opt_(ExpressionSize))
          :GetOffsetExpressionWide => [ HRESULT, [THIS_, PWSTR_OUT, ULONG, PULONG], 26, :convention=>:stdcall ],
          # SetOffsetExpressionWide(THIS_ In_(Expression))
          :SetOffsetExpressionWide => [ HRESULT, [THIS_, PCWSTR], 27, :convention=>:stdcall ],
          # GetGuid(THIS_ Out_(Guid))
          :GetGuid => [ HRESULT, [THIS_, LPGUID], 28, :convention=>:stdcall]
        }

        @lazy_dispatch_table = Hash.new {|h,k|
          prototype = @api_dispatch_table[k]
          if prototype
            # Create the FFI::Function
            h[k] = FFI::Function.new prototype[0], prototype[1], @lazy_vtable[prototype[2]], prototype[3]
          else
            nil
          end
        }

      end

      def ptr
        @interface_ptr
      end

      def ptr= new_ptr
        @interface_ptr = new_ptr
        @vtable = @interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS )
        @lazy_vtable.clear
        @lazy_dispatch_table.clear
      end

      def method_missing( meth, *args )
        raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @lazy_dispatch_table[meth]
        @lazy_dispatch_table[meth].call( ptr, *args )
      end

    end

  end
end
