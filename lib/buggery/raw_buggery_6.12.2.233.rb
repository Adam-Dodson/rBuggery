# This file is 90% autogenerated by munging dbgeng.h, with just enough Ruby to
# wrap the APIs in dispatch tables and then pass things off via method_missing.
# Sorry for the lack of code formatting etc, compyoota done it.
#
# Author: Ben Nagy
# Copyright: Copyright (c) Ben Nagy, 2012 - 2013.
# License: The MIT License
# (See http://www.opensource.org/licenses/mit-license.php for details.)

require 'buggery/fake_com'
require 'win32/wintypes'

require 'ffi'

if ENV['DEBUGGER_PATH']
  DEBUGGER_PATH = ENV['DEBUGGER_PATH']
else
  # Guess.
  DEBUGGER_PATH = [ENV['ProgramFiles'], "Debugging Tools for Windows (x86)"].join("\\")
end
DEBUGGER_DLL  = [DEBUGGER_PATH, "dbgeng.dll"].join("\\")

unless File.exists? DEBUGGER_DLL
  raise RuntimeError, "Unable to find DLLs, please set DEBUGGER_PATH in your
  Environment to the directory where you installed the Windows debugging
  tools." 
end

module Kernel32
  extend FFI::Library
  ffi_lib "kernel32"
  ffi_convention :stdcall

  attach_function :LoadLibraryA, [:string], :ulong
end

# This is so that when dbgeng calls LoadLibrary on dbghelp the correct
# one is already in memory and we don't get the old version from
# %SYSTEMROOT%/system32
Kernel32.LoadLibraryA "#{DEBUGGER_PATH}\\dbghelp"
# If we load the correct dbgeng here, it seems to work without a path in the
# ffi_lib call below. That call fails in Win7 if you give it a full path (don't
# know why).
Kernel32.LoadLibraryA "#{DEBUGGER_PATH}\\dbgeng"

module DbgEng
  extend FFI::Library
  ffi_lib "dbgeng"
  ffi_convention :stdcall

  attach_function :DebugCreate, [:string, :pointer], :ulong
end

# These are parsed out from dbgeng.h
# Not all of these are implemented yet, sorry. I haven't needed any of the
# later version APIs yet.
IIDS={
  'RawBuggery::DebugAdvanced'=>[0xf2df5f53, 0x071f, 0x47bd, 0x9d, 0xe6, 0x57, 0x34, 0xc3, 0xfe, 0xd6, 0x89].pack('LSSC8'),
  'RawBuggery::DebugAdvanced2'=>[0x716d14c9, 0x119b, 0x4ba5, 0xaf, 0x1f, 0x08, 0x90, 0xe6, 0x72, 0x41, 0x6a].pack('LSSC8'),
  'RawBuggery::DebugAdvanced3'=>[0xcba4abb4, 0x84c4, 0x444d, 0x87, 0xca, 0xa0, 0x4e, 0x13, 0x28, 0x67, 0x39].pack('LSSC8'),
  'RawBuggery::DebugBreakpoint'=>[0x5bd9d474, 0x5975, 0x423a, 0xb8, 0x8b, 0x65, 0xa8, 0xe7, 0x11, 0x0e, 0x65].pack('LSSC8'),
  'RawBuggery::DebugBreakpoint2'=>[0x1b278d20, 0x79f2, 0x426e, 0xa3, 0xf9, 0xc1, 0xdd, 0xf3, 0x75, 0xd4, 0x8e].pack('LSSC8'),
  'RawBuggery::DebugClient'=>[0x27fe5639, 0x8407, 0x4f47, 0x83, 0x64, 0xee, 0x11, 0x8f, 0xb0, 0x8a, 0xc8].pack('LSSC8'),
  'RawBuggery::DebugClient2'=>[0xedbed635, 0x372e, 0x4dab, 0xbb, 0xfe, 0xed, 0x0d, 0x2f, 0x63, 0xbe, 0x81].pack('LSSC8'),
  'RawBuggery::DebugClient3'=>[0xdd492d7f, 0x71b8, 0x4ad6, 0xa8, 0xdc, 0x1c, 0x88, 0x74, 0x79, 0xff, 0x91].pack('LSSC8'),
  'RawBuggery::DebugClient4'=>[0xca83c3de, 0x5089, 0x4cf8, 0x93, 0xc8, 0xd8, 0x92, 0x38, 0x7f, 0x2a, 0x5e].pack('LSSC8'),
  'RawBuggery::DebugClient5'=>[0xe3acb9d7, 0x7ec2, 0x4f0c, 0xa0, 0xda, 0xe8, 0x1e, 0x0c, 0xbb, 0xe6, 0x28].pack('LSSC8'),
  'RawBuggery::DebugControl'=>[0x5182e668, 0x105e, 0x416e, 0xad, 0x92, 0x24, 0xef, 0x80, 0x04, 0x24, 0xba].pack('LSSC8'),
  'RawBuggery::DebugControl2'=>[0xd4366723, 0x44df, 0x4bed, 0x8c, 0x7e, 0x4c, 0x05, 0x42, 0x4f, 0x45, 0x88].pack('LSSC8'),
  'RawBuggery::DebugControl3'=>[0x7df74a86, 0xb03f, 0x407f, 0x90, 0xab, 0xa2, 0x0d, 0xad, 0xce, 0xad, 0x08].pack('LSSC8'),
  'RawBuggery::DebugControl4'=>[0x94e60ce9, 0x9b41, 0x4b19, 0x9f, 0xc0, 0x6d, 0x9e, 0xb3, 0x52, 0x72, 0xb3].pack('LSSC8'),
  'RawBuggery::DebugDataSpaces'=>[0x88f7dfab, 0x3ea7, 0x4c3a, 0xae, 0xfb, 0xc4, 0xe8, 0x10, 0x61, 0x73, 0xaa].pack('LSSC8'),
  'RawBuggery::DebugDataSpaces2'=>[0x7a5e852f, 0x96e9, 0x468f, 0xac, 0x1b, 0x0b, 0x3a, 0xdd, 0xc4, 0xa0, 0x49].pack('LSSC8'),
  'RawBuggery::DebugDataSpaces3'=>[0x23f79d6c, 0x8aaf, 0x4f7c, 0xa6, 0x07, 0x99, 0x95, 0xf5, 0x40, 0x7e, 0x63].pack('LSSC8'),
  'RawBuggery::DebugDataSpaces4'=>[0xd98ada1f, 0x29e9, 0x4ef5, 0xa6, 0xc0, 0xe5, 0x33, 0x49, 0x88, 0x32, 0x12].pack('LSSC8'),
  'RawBuggery::DebugEventCallbacks'=>[0x337be28b, 0x5036, 0x4d72, 0xb6, 0xbf, 0xc4, 0x5f, 0xbb, 0x9f, 0x2e, 0xaa].pack('LSSC8'),
  'RawBuggery::DebugEventCallbacksWide'=>[0x0690e046, 0x9c23, 0x45ac, 0xa0, 0x4f, 0x98, 0x7a, 0xc2, 0x9a, 0xd0, 0xd3].pack('LSSC8'),
  'RawBuggery::DebugInputCallbacks'=>[0x9f50e42c, 0xf136, 0x499e, 0x9a, 0x97, 0x73, 0x03, 0x6c, 0x94, 0xed, 0x2d].pack('LSSC8'),
  'RawBuggery::DebugOutputCallbacks'=>[0x4bf58045, 0xd654, 0x4c40, 0xb0, 0xaf, 0x68, 0x30, 0x90, 0xf3, 0x56, 0xdc].pack('LSSC8'),
  'RawBuggery::DebugOutputCallbacksWide'=>[0x4c7fd663, 0xc394, 0x4e26, 0x8e, 0xf1, 0x34, 0xad, 0x5e, 0xd3, 0x76, 0x4c].pack('LSSC8'),
  'RawBuggery::DebugOutputCallbacks2'=>[0x67721fe9, 0x56d2, 0x4a44, 0xa3, 0x25, 0x2b, 0x65, 0x51, 0x3c, 0xe6, 0xeb].pack('LSSC8'),
  'RawBuggery::DebugRegisters'=>[0xce289126, 0x9e84, 0x45a7, 0x93, 0x7e, 0x67, 0xbb, 0x18, 0x69, 0x14, 0x93].pack('LSSC8'),
  'RawBuggery::DebugRegisters2'=>[0x1656afa9, 0x19c6, 0x4e3a, 0x97, 0xe7, 0x5d, 0xc9, 0x16, 0x0c, 0xf9, 0xc4].pack('LSSC8'),
  'RawBuggery::DebugSymbolGroup'=>[0xf2528316, 0x0f1a, 0x4431, 0xae, 0xed, 0x11, 0xd0, 0x96, 0xe1, 0xe2, 0xab].pack('LSSC8'),
  'RawBuggery::DebugSymbolGroup2'=>[0x6a7ccc5f, 0xfb5e, 0x4dcc, 0xb4, 0x1c, 0x6c, 0x20, 0x30, 0x7b, 0xcc, 0xc7].pack('LSSC8'),
  'RawBuggery::DebugSymbols'=>[0x8c31e98c, 0x983a, 0x48a5, 0x90, 0x16, 0x6f, 0xe5, 0xd6, 0x67, 0xa9, 0x50].pack('LSSC8'),
  'RawBuggery::DebugSymbols2'=>[0x3a707211, 0xafdd, 0x4495, 0xad, 0x4f, 0x56, 0xfe, 0xcd, 0xf8, 0x16, 0x3f].pack('LSSC8'),
  'RawBuggery::DebugSymbols3'=>[0xf02fbecc, 0x50ac, 0x4f36, 0x9a, 0xd9, 0xc9, 0x75, 0xe8, 0xf3, 0x2f, 0xf8].pack('LSSC8'),
  'RawBuggery::DebugSystemObjects'=>[0x6b86fe2c, 0x2c4f, 0x4f0c, 0x9d, 0xa2, 0x17, 0x43, 0x11, 0xac, 0xc3, 0x27].pack('LSSC8'),
  'RawBuggery::DebugSystemObjects2'=>[0x0ae9f5ff, 0x1852, 0x4679, 0xb0, 0x55, 0x49, 0x4b, 0xee, 0x64, 0x07, 0xee].pack('LSSC8'),
  'RawBuggery::DebugSystemObjects3'=>[0xe9676e2f, 0xe286, 0x4ea3, 0xb0, 0xf9, 0xdf, 0xe5, 0xd9, 0xfc, 0x33, 0x0e].pack('LSSC8'),
  'RawBuggery::DebugSystemObjects4'=>[0x489468e6, 0x7d0f, 0x4af5, 0x87, 0xab, 0x25, 0x20, 0x74, 0x54, 0xd5, 0x53].pack('LSSC8'),
}
IID_IUnknown=[0x00000000,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46].pack('LSSC8')
IID_IDispatch=[0x00020400,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46].pack('LSSC8')
S_OK=0

module RawBuggery

  # This class is a little bit special, because it will not only dispatch to
  # its own APIs from method_missing, but also to any of the defined client
  # interfaces, like DebugAdvanced, DebugRegisters etc

  class DebugClient

    DEBUG_ATTACH_KERNEL_CONNECTION                  = 0x00000000
    DEBUG_ATTACH_LOCAL_KERNEL                       = 0x00000001
    DEBUG_ATTACH_EXDI_DRIVER                        = 0x00000002
    DEBUG_ATTACH_INSTALL_DRIVER                     = 0x00000004
    DEBUG_GET_PROC_DEFAULT                          = 0x00000000
    DEBUG_GET_PROC_FULL_MATCH                       = 0x00000001
    DEBUG_GET_PROC_ONLY_MATCH                       = 0x00000002
    DEBUG_GET_PROC_SERVICE_NAME                     = 0x00000004
    DEBUG_PROC_DESC_DEFAULT                         = 0x00000000
    DEBUG_PROC_DESC_NO_PATHS                        = 0x00000001
    DEBUG_PROC_DESC_NO_SERVICES                     = 0x00000002
    DEBUG_PROC_DESC_NO_MTS_PACKAGES                 = 0x00000004
    DEBUG_PROC_DESC_NO_COMMAND_LINE                 = 0x00000008
    DEBUG_PROC_DESC_NO_SESSION_ID                   = 0x00000010
    DEBUG_PROC_DESC_NO_USER_NAME                    = 0x00000020
    DEBUG_ATTACH_DEFAULT                            = 0x00000000
    DEBUG_ATTACH_NONINVASIVE                        = 0x00000001
    DEBUG_ATTACH_EXISTING                           = 0x00000002
    DEBUG_ATTACH_NONINVASIVE_NO_SUSPEND             = 0x00000004
    DEBUG_ATTACH_INVASIVE_NO_INITIAL_BREAK          = 0x00000008
    DEBUG_ATTACH_INVASIVE_RESUME_PROCESS            = 0x00000010
    DEBUG_ATTACH_NONINVASIVE_ALLOW_PARTIAL          = 0x00000020
    CREATE_UNICODE_ENVIRONMENT                      = 0x00000400
    STACK_SIZE_PARAM_IS_A_RESERVATION               = 0x00010000
    DEBUG_CREATE_PROCESS_NO_DEBUG_HEAP              = CREATE_UNICODE_ENVIRONMENT
    DEBUG_CREATE_PROCESS_THROUGH_RTL                = STACK_SIZE_PARAM_IS_A_RESERVATION
    DEBUG_ECREATE_PROCESS_DEFAULT                   = 0x00000000
    DEBUG_ECREATE_PROCESS_INHERIT_HANDLES           = 0x00000001
    DEBUG_ECREATE_PROCESS_USE_VERIFIER_FLAGS        = 0x00000002
    DEBUG_ECREATE_PROCESS_USE_IMPLICIT_COMMAND_LINE = 0x00000004
    DEBUG_PROCESS_DETACH_ON_EXIT                    = 0x00000001
    DEBUG_PROCESS_ONLY_THIS_PROCESS                 = 0x00000002
    DEBUG_CONNECT_SESSION_DEFAULT                   = 0x00000000
    DEBUG_CONNECT_SESSION_NO_VERSION                = 0x00000001
    DEBUG_CONNECT_SESSION_NO_ANNOUNCE               = 0x00000002
    DEBUG_SERVERS_DEBUGGER                          = 0x00000001
    DEBUG_SERVERS_PROCESS                           = 0x00000002
    DEBUG_SERVERS_ALL                               = 0x00000003
    DEBUG_END_PASSIVE                               = 0x00000000
    DEBUG_END_ACTIVE_TERMINATE                      = 0x00000001
    DEBUG_END_ACTIVE_DETACH                         = 0x00000002
    DEBUG_END_REENTRANT                             = 0x00000003
    DEBUG_END_DISCONNECT                            = 0x00000004
    DEBUG_OUTPUT_NORMAL                             = 0x00000001
    DEBUG_OUTPUT_ERROR                              = 0x00000002
    DEBUG_OUTPUT_WARNING                            = 0x00000004
    DEBUG_OUTPUT_VERBOSE                            = 0x00000008
    DEBUG_OUTPUT_PROMPT                             = 0x00000010
    DEBUG_OUTPUT_PROMPT_REGISTERS                   = 0x00000020
    DEBUG_OUTPUT_EXTENSION_WARNING                  = 0x00000040
    DEBUG_OUTPUT_DEBUGGEE                           = 0x00000080
    DEBUG_OUTPUT_DEBUGGEE_PROMPT                    = 0x00000100
    DEBUG_OUTPUT_SYMBOLS                            = 0x00000200
    DEBUG_IOUTPUT_KD_PROTOCOL                       = 0x80000000
    DEBUG_IOUTPUT_REMOTING                          = 0x40000000
    DEBUG_IOUTPUT_BREAKPOINT                        = 0x20000000
    DEBUG_IOUTPUT_EVENT                             = 0x10000000
    DEBUG_IOUTPUT_ADDR_TRANSLATE                    = 0x08000000
    DEBUG_OUTPUT_IDENTITY_DEFAULT                   = 0x00000000

    NUM_APIS = 48

    include Win32::WinTypes

    def initialize

      # Get a pointer to the DebugClient interface
      ptr = FFI::MemoryPointer.new :pointer
      DbgEng.DebugCreate IIDS[self.class.to_s], ptr
      @interface_ptr = ptr.get_pointer(0)
      raise "#{self.class}: Unable to get interface pointer!" if @interface_ptr.address.zero?

      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      @interface_table={} # empty for now, built as needed

      # These are autogenerated from dbgeng.h and may contain errors!

      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :AttachKernel => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[3], :convention=>:stdcall  ),
        :GetKernelConnectionOptions => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[4], :convention=>:stdcall  ),
        :SetKernelConnectionOptions => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[5], :convention=>:stdcall  ),
        :StartProcessServer => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, PVOID], @vtable[6], :convention=>:stdcall  ),
        :ConnectProcessServer => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG64], @vtable[7], :convention=>:stdcall  ),
        :DisconnectProcessServer => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[8], :convention=>:stdcall  ),
        :GetRunningProcessSystemIds => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG, ULONG, PULONG], @vtable[9], :convention=>:stdcall  ),
        :GetRunningProcessSystemIdByExecutableName => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCSTR, ULONG, PULONG], @vtable[10], :convention=>:stdcall  ),
        :GetRunningProcessDescription => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, ULONG, PSTR_OUT, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[11], :convention=>:stdcall  ),
        :AttachProcess => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, ULONG], @vtable[12], :convention=>:stdcall  ),
        :CreateProcess => FFI::Function.new( HRESULT, [THIS_, ULONG64, PSTR, ULONG], @vtable[13], :convention=>:stdcall  ),
        :CreateProcessAndAttach => FFI::Function.new( HRESULT, [THIS_, ULONG64, PSTR, ULONG, ULONG, ULONG], @vtable[14], :convention=>:stdcall  ),
        :GetProcessOptions => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[15], :convention=>:stdcall  ),
        :AddProcessOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[16], :convention=>:stdcall  ),
        :RemoveProcessOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[17], :convention=>:stdcall  ),
        :SetProcessOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[18], :convention=>:stdcall  ),
        :OpenDumpFile => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[19], :convention=>:stdcall  ),
        :WriteDumpFile => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG], @vtable[20], :convention=>:stdcall  ),
        :ConnectSession => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[21], :convention=>:stdcall  ),
        :StartServer => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[22], :convention=>:stdcall  ),
        :OutputServers => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ULONG], @vtable[23], :convention=>:stdcall  ),
        :TerminateProcesses => FFI::Function.new( HRESULT, [THIS_], @vtable[24], :convention=>:stdcall  ),
        :DetachProcesses => FFI::Function.new( HRESULT, [THIS_], @vtable[25], :convention=>:stdcall  ),
        :EndSession => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[26], :convention=>:stdcall  ),
        :GetExitCode => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[27], :convention=>:stdcall  ),
        :DispatchCallbacks => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[28], :convention=>:stdcall  ),
        :ExitDispatch => FFI::Function.new( HRESULT, [THIS_, PDEBUG_CLIENT], @vtable[29], :convention=>:stdcall  ),
        :CreateClient => FFI::Function.new( HRESULT, [THIS_, PDEBUG_CLIENT], @vtable[30], :convention=>:stdcall  ),
        :GetInputCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_INPUT_CALLBACKS], @vtable[31], :convention=>:stdcall  ),
        :SetInputCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_INPUT_CALLBACKS], @vtable[32], :convention=>:stdcall  ),
        :GetOutputCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_OUTPUT_CALLBACKS], @vtable[33], :convention=>:stdcall  ),
        :SetOutputCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_OUTPUT_CALLBACKS], @vtable[34], :convention=>:stdcall  ),
        :GetOutputMask => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[35], :convention=>:stdcall  ),
        :SetOutputMask => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[36], :convention=>:stdcall  ),
        :GetOtherOutputMask => FFI::Function.new( HRESULT, [THIS_, PDEBUG_CLIENT, PULONG], @vtable[37], :convention=>:stdcall  ),
        :SetOtherOutputMask => FFI::Function.new( HRESULT, [THIS_, PDEBUG_CLIENT, ULONG], @vtable[38], :convention=>:stdcall  ),
        :GetOutputWidth => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[39], :convention=>:stdcall  ),
        :SetOutputWidth => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[40], :convention=>:stdcall  ),
        :GetOutputLinePrefix => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[41], :convention=>:stdcall  ),
        :SetOutputLinePrefix => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[42], :convention=>:stdcall  ),
        :GetIdentity => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[43], :convention=>:stdcall  ),
        :OutputIdentity => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PCSTR], @vtable[44], :convention=>:stdcall  ),
        :GetEventCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_EVENT_CALLBACKS], @vtable[45], :convention=>:stdcall  ),
        :SetEventCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_EVENT_CALLBACKS], @vtable[46], :convention=>:stdcall  ),
        :FlushCallbacks => FFI::Function.new( HRESULT, [THIS_], @vtable[47], :convention=>:stdcall  )
      }

    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      unless @api_dispatch_table[meth]
        begin
          # Maybe it's a subinterface?
          @interface_table[meth]||=RawBuggery.const_get( meth ).new( self )
        rescue
          # Then again, maybe not.
          raise ArgumentError, "#{self.class}: Invalid API #{meth} #{$!} #{$@.join("\n")}"
        end
      else
        @api_dispatch_table[meth].call( @interface_ptr, *args )
      end
    end

  end
  class DebugAdvanced

    NUM_APIS = 5

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :GetThreadContext => FFI::Function.new( HRESULT, [THIS_, PVOID, ULONG], @vtable[3], :convention=>:stdcall  ),
        :SetThreadContext => FFI::Function.new( HRESULT, [THIS_, PVOID, ULONG], @vtable[4], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugAdvanced2
    
    DEBUG_GET_TEXT_COMPLETIONS_NO_DOT_COMMANDS           = 0x00000001
    DEBUG_GET_TEXT_COMPLETIONS_NO_EXTENSION_COMMANDS     = 0x00000002
    DEBUG_GET_TEXT_COMPLETIONS_NO_SYMBOLS                = 0x00000004
    DEBUG_GET_TEXT_COMPLETIONS_IS_DOT_COMMAND            = 0x00000001
    DEBUG_GET_TEXT_COMPLETIONS_IS_EXTENSION_COMMAND      = 0x00000002
    DEBUG_GET_TEXT_COMPLETIONS_IS_SYMBOL                 = 0x00000004
    DEBUG_REQUEST_SOURCE_PATH_HAS_SOURCE_SERVER          = 0
    DEBUG_REQUEST_TARGET_EXCEPTION_CONTEXT               = 1
    DEBUG_REQUEST_TARGET_EXCEPTION_THREAD                = 2
    DEBUG_REQUEST_TARGET_EXCEPTION_RECORD                = 3
    DEBUG_REQUEST_GET_ADDITIONAL_CREATE_OPTIONS          = 4
    DEBUG_REQUEST_SET_ADDITIONAL_CREATE_OPTIONS          = 5
    DEBUG_REQUEST_GET_WIN32_MAJOR_MINOR_VERSIONS         = 6
    DEBUG_REQUEST_READ_USER_MINIDUMP_STREAM              = 7
    DEBUG_REQUEST_TARGET_CAN_DETACH                      = 8
    DEBUG_REQUEST_SET_LOCAL_IMPLICIT_COMMAND_LINE        = 9
    DEBUG_REQUEST_GET_CAPTURED_EVENT_CODE_OFFSET         = 10
    DEBUG_REQUEST_READ_CAPTURED_EVENT_CODE_STREAM        = 11
    DEBUG_REQUEST_EXT_TYPED_DATA_ANSI                    = 12
    DEBUG_REQUEST_GET_EXTENSION_SEARCH_PATH_WIDE         = 13
    DEBUG_REQUEST_GET_TEXT_COMPLETIONS_WIDE              = 14
    DEBUG_REQUEST_GET_CACHED_SYMBOL_INFO                 = 15
    DEBUG_REQUEST_ADD_CACHED_SYMBOL_INFO                 = 16
    DEBUG_REQUEST_REMOVE_CACHED_SYMBOL_INFO              = 17
    DEBUG_REQUEST_GET_TEXT_COMPLETIONS_ANSI              = 18
    DEBUG_REQUEST_CURRENT_OUTPUT_CALLBACKS_ARE_DML_AWARE = 19
    DEBUG_REQUEST_GET_OFFSET_UNWIND_INFORMATION          = 20
    DEBUG_REQUEST_GET_DUMP_HEADER                        = 21
    DEBUG_REQUEST_SET_DUMP_HEADER                        = 22
    DEBUG_REQUEST_MIDORI                                 = 23
    DEBUG_REQUEST_PROCESS_DESCRIPTORS                    = 24
    DEBUG_REQUEST_MISC_INFORMATION                       = 25
    DEBUG_REQUEST_OPEN_PROCESS_TOKEN                     = 26
    DEBUG_REQUEST_OPEN_THREAD_TOKEN                      = 27
    DEBUG_REQUEST_DUPLICATE_TOKEN                        = 28
    DEBUG_REQUEST_QUERY_INFO_TOKEN                       = 29
    DEBUG_REQUEST_CLOSE_TOKEN                            = 30
    DEBUG_SRCFILE_SYMBOL_TOKEN                           = 0
    DEBUG_SRCFILE_SYMBOL_TOKEN_SOURCE_COMMAND_WIDE       = 1
    DEBUG_SYMINFO_BREAKPOINT_SOURCE_LINE                 = 0
    DEBUG_SYMINFO_IMAGEHLP_MODULEW64                     = 1
    DEBUG_SYMINFO_GET_SYMBOL_NAME_BY_OFFSET_AND_TAG_WIDE = 2
    DEBUG_SYMINFO_GET_MODULE_SYMBOL_NAMES_AND_OFFSETS    = 3
    DEBUG_SYSOBJINFO_THREAD_BASIC_INFORMATION            = 0
    DEBUG_SYSOBJINFO_THREAD_NAME_WIDE                    = 1
    DEBUG_SYSOBJINFO_CURRENT_PROCESS_COOKIE              = 2
    DEBUG_TBINFO_EXIT_STATUS                             = 0x00000001
    DEBUG_TBINFO_PRIORITY_CLASS                          = 0x00000002
    DEBUG_TBINFO_PRIORITY                                = 0x00000004
    DEBUG_TBINFO_TIMES                                   = 0x00000008
    DEBUG_TBINFO_START_OFFSET                            = 0x00000010
    DEBUG_TBINFO_AFFINITY                                = 0x00000020
    DEBUG_TBINFO_ALL                                     = 0x0000003f

    NUM_APIS = 10

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :GetThreadContext => FFI::Function.new( HRESULT, [THIS_, PVOID, ULONG], @vtable[3], :convention=>:stdcall  ),
        :SetThreadContext => FFI::Function.new( HRESULT, [THIS_, PVOID, ULONG], @vtable[4], :convention=>:stdcall  ),
        :Request => FFI::Function.new( HRESULT, [THIS_, ULONG, PVOID, ULONG, PVOID, ULONG, PULONG], @vtable[5], :convention=>:stdcall  ),
        :GetSourceFileInformation => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[6], :convention=>:stdcall  ),
        :FindSourceFileAndToken => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PCSTR, ULONG, PVOID, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[7], :convention=>:stdcall  ),
        :GetSymbolInformation => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, ULONG, PVOID, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[8], :convention=>:stdcall  ),
        :GetSystemObjectInformation => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[9], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugAdvanced3

    NUM_APIS = 13

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :GetThreadContext => FFI::Function.new( HRESULT, [THIS_, PVOID, ULONG], @vtable[3], :convention=>:stdcall  ),
        :SetThreadContext => FFI::Function.new( HRESULT, [THIS_, PVOID, ULONG], @vtable[4], :convention=>:stdcall  ),
        :Request => FFI::Function.new( HRESULT, [THIS_, ULONG, PVOID, ULONG, PVOID, ULONG, PULONG], @vtable[5], :convention=>:stdcall  ),
        :GetSourceFileInformation => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[6], :convention=>:stdcall  ),
        :FindSourceFileAndToken => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PCSTR, ULONG, PVOID, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[7], :convention=>:stdcall  ),
        :GetSymbolInformation => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, ULONG, PVOID, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[8], :convention=>:stdcall  ),
        :GetSystemObjectInformation => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[9], :convention=>:stdcall  ),
        :GetSourceFileInformationWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PWSTR, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[10], :convention=>:stdcall  ),
        :FindSourceFileAndTokenWide => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PCWSTR, ULONG, PVOID, ULONG, PULONG, PWSTR_OUT, ULONG, PULONG], @vtable[11], :convention=>:stdcall  ),
        :GetSymbolInformationWide => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, ULONG, PVOID, ULONG, PULONG, PWSTR_OUT, ULONG, PULONG], @vtable[12], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugBreakpoint

    DEBUG_BREAKPOINT_CODE       = 0
    DEBUG_BREAKPOINT_DATA       = 1
    DEBUG_BREAKPOINT_TIME       = 2
    DEBUG_BREAKPOINT_GO_ONLY    = 0x00000001
    DEBUG_BREAKPOINT_DEFERRED   = 0x00000002
    DEBUG_BREAKPOINT_ENABLED    = 0x00000004
    DEBUG_BREAKPOINT_ADDER_ONLY = 0x00000008
    DEBUG_BREAKPOINT_ONE_SHOT   = 0x00000010
    DEBUG_BREAK_READ            = 0x00000001
    DEBUG_BREAK_WRITE           = 0x00000002
    DEBUG_BREAK_EXECUTE         = 0x00000004
    DEBUG_BREAK_IO              = 0x00000008

    NUM_APIS = 24

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :GetId => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[3], :convention=>:stdcall  ),
        :GetType => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG], @vtable[4], :convention=>:stdcall  ),
        :GetAdder => FFI::Function.new( HRESULT, [THIS_, PDEBUG_CLIENT], @vtable[5], :convention=>:stdcall  ),
        :GetFlags => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[6], :convention=>:stdcall  ),
        :AddFlags => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[7], :convention=>:stdcall  ),
        :RemoveFlags => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[8], :convention=>:stdcall  ),
        :SetFlags => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[9], :convention=>:stdcall  ),
        :GetOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[10], :convention=>:stdcall  ),
        :SetOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[11], :convention=>:stdcall  ),
        :GetDataParameters => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG], @vtable[12], :convention=>:stdcall  ),
        :SetDataParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[13], :convention=>:stdcall  ),
        :GetPassCount => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[14], :convention=>:stdcall  ),
        :SetPassCount => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[15], :convention=>:stdcall  ),
        :GetCurrentPassCount => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[16], :convention=>:stdcall  ),
        :GetMatchThreadId => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[17], :convention=>:stdcall  ),
        :SetMatchThreadId => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[18], :convention=>:stdcall  ),
        :GetCommand => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[19], :convention=>:stdcall  ),
        :SetCommand => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[20], :convention=>:stdcall  ),
        :GetOffsetExpression => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[21], :convention=>:stdcall  ),
        :SetOffsetExpression => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[22], :convention=>:stdcall  ),
        :GetParameters => FFI::Function.new( HRESULT, [THIS_, PDEBUG_BREAKPOINT_PARAMETERS], @vtable[23], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugBreakpoint2

    NUM_APIS = 28

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :GetId => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[3], :convention=>:stdcall  ),
        :GetType => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG], @vtable[4], :convention=>:stdcall  ),
        :GetAdder => FFI::Function.new( HRESULT, [THIS_, PDEBUG_CLIENT], @vtable[5], :convention=>:stdcall  ),
        :GetFlags => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[6], :convention=>:stdcall  ),
        :AddFlags => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[7], :convention=>:stdcall  ),
        :RemoveFlags => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[8], :convention=>:stdcall  ),
        :SetFlags => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[9], :convention=>:stdcall  ),
        :GetOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[10], :convention=>:stdcall  ),
        :SetOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[11], :convention=>:stdcall  ),
        :GetDataParameters => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG], @vtable[12], :convention=>:stdcall  ),
        :SetDataParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[13], :convention=>:stdcall  ),
        :GetPassCount => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[14], :convention=>:stdcall  ),
        :SetPassCount => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[15], :convention=>:stdcall  ),
        :GetCurrentPassCount => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[16], :convention=>:stdcall  ),
        :GetMatchThreadId => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[17], :convention=>:stdcall  ),
        :SetMatchThreadId => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[18], :convention=>:stdcall  ),
        :GetCommand => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[19], :convention=>:stdcall  ),
        :SetCommand => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[20], :convention=>:stdcall  ),
        :GetOffsetExpression => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[21], :convention=>:stdcall  ),
        :SetOffsetExpression => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[22], :convention=>:stdcall  ),
        :GetParameters => FFI::Function.new( HRESULT, [THIS_, PDEBUG_BREAKPOINT_PARAMETERS], @vtable[23], :convention=>:stdcall  ),
        :GetCommandWide => FFI::Function.new( HRESULT, [THIS_, PWSTR_OUT, ULONG, PULONG], @vtable[24], :convention=>:stdcall  ),
        :SetCommandWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR], @vtable[25], :convention=>:stdcall  ),
        :GetOffsetExpressionWide => FFI::Function.new( HRESULT, [THIS_, PWSTR_OUT, ULONG, PULONG], @vtable[26], :convention=>:stdcall  ),
        :SetOffsetExpressionWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR], @vtable[27], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end


  class DebugClient2

    DEBUG_FORMAT_DEFAULT                              = 0x00000000
    DEBUG_FORMAT_CAB_SECONDARY_ALL_IMAGES             = 0x10000000
    DEBUG_FORMAT_WRITE_CAB                            = 0x20000000
    DEBUG_FORMAT_CAB_SECONDARY_FILES                  = 0x40000000
    DEBUG_FORMAT_NO_OVERWRITE                         = 0x80000000
    DEBUG_FORMAT_USER_SMALL_FULL_MEMORY               = 0x00000001
    DEBUG_FORMAT_USER_SMALL_HANDLE_DATA               = 0x00000002
    DEBUG_FORMAT_USER_SMALL_UNLOADED_MODULES          = 0x00000004
    DEBUG_FORMAT_USER_SMALL_INDIRECT_MEMORY           = 0x00000008
    DEBUG_FORMAT_USER_SMALL_DATA_SEGMENTS             = 0x00000010
    DEBUG_FORMAT_USER_SMALL_FILTER_MEMORY             = 0x00000020
    DEBUG_FORMAT_USER_SMALL_FILTER_PATHS              = 0x00000040
    DEBUG_FORMAT_USER_SMALL_PROCESS_THREAD_DATA       = 0x00000080
    DEBUG_FORMAT_USER_SMALL_PRIVATE_READ_WRITE_MEMORY = 0x00000100
    DEBUG_FORMAT_USER_SMALL_NO_OPTIONAL_DATA          = 0x00000200
    DEBUG_FORMAT_USER_SMALL_FULL_MEMORY_INFO          = 0x00000400
    DEBUG_FORMAT_USER_SMALL_THREAD_INFO               = 0x00000800
    DEBUG_FORMAT_USER_SMALL_CODE_SEGMENTS             = 0x00001000
    DEBUG_FORMAT_USER_SMALL_NO_AUXILIARY_STATE        = 0x00002000
    DEBUG_FORMAT_USER_SMALL_FULL_AUXILIARY_STATE      = 0x00004000
    DEBUG_FORMAT_USER_SMALL_IGNORE_INACCESSIBLE_MEM   = 0x08000000
    DEBUG_DUMP_FILE_BASE                              = 0xffffffff
    DEBUG_DUMP_FILE_PAGE_FILE_DUMP                    = 0x00000000

    NUM_APIS = 56

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :AttachKernel => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[3], :convention=>:stdcall  ),
        :GetKernelConnectionOptions => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[4], :convention=>:stdcall  ),
        :SetKernelConnectionOptions => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[5], :convention=>:stdcall  ),
        :StartProcessServer => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, PVOID], @vtable[6], :convention=>:stdcall  ),
        :ConnectProcessServer => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG64], @vtable[7], :convention=>:stdcall  ),
        :DisconnectProcessServer => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[8], :convention=>:stdcall  ),
        :GetRunningProcessSystemIds => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG, ULONG, PULONG], @vtable[9], :convention=>:stdcall  ),
        :GetRunningProcessSystemIdByExecutableName => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCSTR, ULONG, PULONG], @vtable[10], :convention=>:stdcall  ),
        :GetRunningProcessDescription => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, ULONG, PSTR_OUT, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[11], :convention=>:stdcall  ),
        :AttachProcess => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, ULONG], @vtable[12], :convention=>:stdcall  ),
        :CreateProcess => FFI::Function.new( HRESULT, [THIS_, ULONG64, PSTR, ULONG], @vtable[13], :convention=>:stdcall  ),
        :CreateProcessAndAttach => FFI::Function.new( HRESULT, [THIS_, ULONG64, PSTR, ULONG, ULONG, ULONG], @vtable[14], :convention=>:stdcall  ),
        :GetProcessOptions => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[15], :convention=>:stdcall  ),
        :AddProcessOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[16], :convention=>:stdcall  ),
        :RemoveProcessOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[17], :convention=>:stdcall  ),
        :SetProcessOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[18], :convention=>:stdcall  ),
        :OpenDumpFile => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[19], :convention=>:stdcall  ),
        :WriteDumpFile => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG], @vtable[20], :convention=>:stdcall  ),
        :ConnectSession => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[21], :convention=>:stdcall  ),
        :StartServer => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[22], :convention=>:stdcall  ),
        :OutputServers => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ULONG], @vtable[23], :convention=>:stdcall  ),
        :TerminateProcesses => FFI::Function.new( HRESULT, [THIS_], @vtable[24], :convention=>:stdcall  ),
        :DetachProcesses => FFI::Function.new( HRESULT, [THIS_], @vtable[25], :convention=>:stdcall  ),
        :EndSession => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[26], :convention=>:stdcall  ),
        :GetExitCode => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[27], :convention=>:stdcall  ),
        :DispatchCallbacks => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[28], :convention=>:stdcall  ),
        :ExitDispatch => FFI::Function.new( HRESULT, [THIS_, PDEBUG_CLIENT], @vtable[29], :convention=>:stdcall  ),
        :CreateClient => FFI::Function.new( HRESULT, [THIS_, PDEBUG_CLIENT], @vtable[30], :convention=>:stdcall  ),
        :GetInputCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_INPUT_CALLBACKS], @vtable[31], :convention=>:stdcall  ),
        :SetInputCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_INPUT_CALLBACKS], @vtable[32], :convention=>:stdcall  ),
        :GetOutputCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_OUTPUT_CALLBACKS], @vtable[33], :convention=>:stdcall  ),
        :SetOutputCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_OUTPUT_CALLBACKS], @vtable[34], :convention=>:stdcall  ),
        :GetOutputMask => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[35], :convention=>:stdcall  ),
        :SetOutputMask => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[36], :convention=>:stdcall  ),
        :GetOtherOutputMask => FFI::Function.new( HRESULT, [THIS_, PDEBUG_CLIENT, PULONG], @vtable[37], :convention=>:stdcall  ),
        :SetOtherOutputMask => FFI::Function.new( HRESULT, [THIS_, PDEBUG_CLIENT, ULONG], @vtable[38], :convention=>:stdcall  ),
        :GetOutputWidth => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[39], :convention=>:stdcall  ),
        :SetOutputWidth => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[40], :convention=>:stdcall  ),
        :GetOutputLinePrefix => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[41], :convention=>:stdcall  ),
        :SetOutputLinePrefix => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[42], :convention=>:stdcall  ),
        :GetIdentity => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[43], :convention=>:stdcall  ),
        :OutputIdentity => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PCSTR], @vtable[44], :convention=>:stdcall  ),
        :GetEventCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_EVENT_CALLBACKS], @vtable[45], :convention=>:stdcall  ),
        :SetEventCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_EVENT_CALLBACKS], @vtable[46], :convention=>:stdcall  ),
        :FlushCallbacks => FFI::Function.new( HRESULT, [THIS_], @vtable[47], :convention=>:stdcall  ),
        :WriteDumpFile2 => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG, ULONG, PCSTR], @vtable[48], :convention=>:stdcall  ),
        :AddDumpInformationFile => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG], @vtable[49], :convention=>:stdcall  ),
        :EndProcessServer => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[50], :convention=>:stdcall  ),
        :WaitForProcessServerEnd => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[51], :convention=>:stdcall  ),
        :IsKernelDebuggerEnabled => FFI::Function.new( HRESULT, [THIS_], @vtable[52], :convention=>:stdcall  ),
        :TerminateCurrentProcess => FFI::Function.new( HRESULT, [THIS_], @vtable[53], :convention=>:stdcall  ),
        :DetachCurrentProcess => FFI::Function.new( HRESULT, [THIS_], @vtable[54], :convention=>:stdcall  ),
        :AbandonCurrentProcess => FFI::Function.new( HRESULT, [THIS_], @vtable[55], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugClient3

    NUM_APIS = 60

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :AttachKernel => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[3], :convention=>:stdcall  ),
        :GetKernelConnectionOptions => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[4], :convention=>:stdcall  ),
        :SetKernelConnectionOptions => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[5], :convention=>:stdcall  ),
        :StartProcessServer => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, PVOID], @vtable[6], :convention=>:stdcall  ),
        :ConnectProcessServer => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG64], @vtable[7], :convention=>:stdcall  ),
        :DisconnectProcessServer => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[8], :convention=>:stdcall  ),
        :GetRunningProcessSystemIds => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG, ULONG, PULONG], @vtable[9], :convention=>:stdcall  ),
        :GetRunningProcessSystemIdByExecutableName => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCSTR, ULONG, PULONG], @vtable[10], :convention=>:stdcall  ),
        :GetRunningProcessDescription => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, ULONG, PSTR_OUT, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[11], :convention=>:stdcall  ),
        :AttachProcess => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, ULONG], @vtable[12], :convention=>:stdcall  ),
        :CreateProcess => FFI::Function.new( HRESULT, [THIS_, ULONG64, PSTR, ULONG], @vtable[13], :convention=>:stdcall  ),
        :CreateProcessAndAttach => FFI::Function.new( HRESULT, [THIS_, ULONG64, PSTR, ULONG, ULONG, ULONG], @vtable[14], :convention=>:stdcall  ),
        :GetProcessOptions => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[15], :convention=>:stdcall  ),
        :AddProcessOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[16], :convention=>:stdcall  ),
        :RemoveProcessOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[17], :convention=>:stdcall  ),
        :SetProcessOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[18], :convention=>:stdcall  ),
        :OpenDumpFile => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[19], :convention=>:stdcall  ),
        :WriteDumpFile => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG], @vtable[20], :convention=>:stdcall  ),
        :ConnectSession => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[21], :convention=>:stdcall  ),
        :StartServer => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[22], :convention=>:stdcall  ),
        :OutputServers => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ULONG], @vtable[23], :convention=>:stdcall  ),
        :TerminateProcesses => FFI::Function.new( HRESULT, [THIS_], @vtable[24], :convention=>:stdcall  ),
        :DetachProcesses => FFI::Function.new( HRESULT, [THIS_], @vtable[25], :convention=>:stdcall  ),
        :EndSession => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[26], :convention=>:stdcall  ),
        :GetExitCode => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[27], :convention=>:stdcall  ),
        :DispatchCallbacks => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[28], :convention=>:stdcall  ),
        :ExitDispatch => FFI::Function.new( HRESULT, [THIS_, PDEBUG_CLIENT], @vtable[29], :convention=>:stdcall  ),
        :CreateClient => FFI::Function.new( HRESULT, [THIS_, PDEBUG_CLIENT], @vtable[30], :convention=>:stdcall  ),
        :GetInputCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_INPUT_CALLBACKS], @vtable[31], :convention=>:stdcall  ),
        :SetInputCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_INPUT_CALLBACKS], @vtable[32], :convention=>:stdcall  ),
        :GetOutputCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_OUTPUT_CALLBACKS], @vtable[33], :convention=>:stdcall  ),
        :SetOutputCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_OUTPUT_CALLBACKS], @vtable[34], :convention=>:stdcall  ),
        :GetOutputMask => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[35], :convention=>:stdcall  ),
        :SetOutputMask => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[36], :convention=>:stdcall  ),
        :GetOtherOutputMask => FFI::Function.new( HRESULT, [THIS_, PDEBUG_CLIENT, PULONG], @vtable[37], :convention=>:stdcall  ),
        :SetOtherOutputMask => FFI::Function.new( HRESULT, [THIS_, PDEBUG_CLIENT, ULONG], @vtable[38], :convention=>:stdcall  ),
        :GetOutputWidth => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[39], :convention=>:stdcall  ),
        :SetOutputWidth => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[40], :convention=>:stdcall  ),
        :GetOutputLinePrefix => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[41], :convention=>:stdcall  ),
        :SetOutputLinePrefix => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[42], :convention=>:stdcall  ),
        :GetIdentity => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[43], :convention=>:stdcall  ),
        :OutputIdentity => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PCSTR], @vtable[44], :convention=>:stdcall  ),
        :GetEventCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_EVENT_CALLBACKS], @vtable[45], :convention=>:stdcall  ),
        :SetEventCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_EVENT_CALLBACKS], @vtable[46], :convention=>:stdcall  ),
        :FlushCallbacks => FFI::Function.new( HRESULT, [THIS_], @vtable[47], :convention=>:stdcall  ),
        :WriteDumpFile2 => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG, ULONG, PCSTR], @vtable[48], :convention=>:stdcall  ),
        :AddDumpInformationFile => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG], @vtable[49], :convention=>:stdcall  ),
        :EndProcessServer => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[50], :convention=>:stdcall  ),
        :WaitForProcessServerEnd => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[51], :convention=>:stdcall  ),
        :IsKernelDebuggerEnabled => FFI::Function.new( HRESULT, [THIS_], @vtable[52], :convention=>:stdcall  ),
        :TerminateCurrentProcess => FFI::Function.new( HRESULT, [THIS_], @vtable[53], :convention=>:stdcall  ),
        :DetachCurrentProcess => FFI::Function.new( HRESULT, [THIS_], @vtable[54], :convention=>:stdcall  ),
        :AbandonCurrentProcess => FFI::Function.new( HRESULT, [THIS_], @vtable[55], :convention=>:stdcall  ),
        :GetRunningProcessSystemIdByExecutableNameWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCWSTR, ULONG, PULONG], @vtable[56], :convention=>:stdcall  ),
        :GetRunningProcessDescriptionWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, ULONG, PWSTR_OUT, ULONG, PULONG, PWSTR_OUT, ULONG, PULONG], @vtable[57], :convention=>:stdcall  ),
        :CreateProcessWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, PWSTR, ULONG], @vtable[58], :convention=>:stdcall  ),
        :CreateProcessAndAttachWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, PWSTR, ULONG, ULONG, ULONG], @vtable[59], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugClient4

    DEBUG_DUMP_FILE_LOAD_FAILED_INDEX  = 0xffffffff
    DEBUG_DUMP_FILE_ORIGINAL_CAB_INDEX = 0xfffffffe

    NUM_APIS = 66

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :AttachKernel => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[3], :convention=>:stdcall  ),
        :GetKernelConnectionOptions => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[4], :convention=>:stdcall  ),
        :SetKernelConnectionOptions => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[5], :convention=>:stdcall  ),
        :StartProcessServer => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, PVOID], @vtable[6], :convention=>:stdcall  ),
        :ConnectProcessServer => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG64], @vtable[7], :convention=>:stdcall  ),
        :DisconnectProcessServer => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[8], :convention=>:stdcall  ),
        :GetRunningProcessSystemIds => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG, ULONG, PULONG], @vtable[9], :convention=>:stdcall  ),
        :GetRunningProcessSystemIdByExecutableName => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCSTR, ULONG, PULONG], @vtable[10], :convention=>:stdcall  ),
        :GetRunningProcessDescription => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, ULONG, PSTR_OUT, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[11], :convention=>:stdcall  ),
        :AttachProcess => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, ULONG], @vtable[12], :convention=>:stdcall  ),
        :CreateProcess => FFI::Function.new( HRESULT, [THIS_, ULONG64, PSTR, ULONG], @vtable[13], :convention=>:stdcall  ),
        :CreateProcessAndAttach => FFI::Function.new( HRESULT, [THIS_, ULONG64, PSTR, ULONG, ULONG, ULONG], @vtable[14], :convention=>:stdcall  ),
        :GetProcessOptions => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[15], :convention=>:stdcall  ),
        :AddProcessOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[16], :convention=>:stdcall  ),
        :RemoveProcessOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[17], :convention=>:stdcall  ),
        :SetProcessOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[18], :convention=>:stdcall  ),
        :OpenDumpFile => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[19], :convention=>:stdcall  ),
        :WriteDumpFile => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG], @vtable[20], :convention=>:stdcall  ),
        :ConnectSession => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[21], :convention=>:stdcall  ),
        :StartServer => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[22], :convention=>:stdcall  ),
        :OutputServers => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ULONG], @vtable[23], :convention=>:stdcall  ),
        :TerminateProcesses => FFI::Function.new( HRESULT, [THIS_], @vtable[24], :convention=>:stdcall  ),
        :DetachProcesses => FFI::Function.new( HRESULT, [THIS_], @vtable[25], :convention=>:stdcall  ),
        :EndSession => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[26], :convention=>:stdcall  ),
        :GetExitCode => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[27], :convention=>:stdcall  ),
        :DispatchCallbacks => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[28], :convention=>:stdcall  ),
        :ExitDispatch => FFI::Function.new( HRESULT, [THIS_, PDEBUG_CLIENT], @vtable[29], :convention=>:stdcall  ),
        :CreateClient => FFI::Function.new( HRESULT, [THIS_, PDEBUG_CLIENT], @vtable[30], :convention=>:stdcall  ),
        :GetInputCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_INPUT_CALLBACKS], @vtable[31], :convention=>:stdcall  ),
        :SetInputCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_INPUT_CALLBACKS], @vtable[32], :convention=>:stdcall  ),
        :GetOutputCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_OUTPUT_CALLBACKS], @vtable[33], :convention=>:stdcall  ),
        :SetOutputCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_OUTPUT_CALLBACKS], @vtable[34], :convention=>:stdcall  ),
        :GetOutputMask => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[35], :convention=>:stdcall  ),
        :SetOutputMask => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[36], :convention=>:stdcall  ),
        :GetOtherOutputMask => FFI::Function.new( HRESULT, [THIS_, PDEBUG_CLIENT, PULONG], @vtable[37], :convention=>:stdcall  ),
        :SetOtherOutputMask => FFI::Function.new( HRESULT, [THIS_, PDEBUG_CLIENT, ULONG], @vtable[38], :convention=>:stdcall  ),
        :GetOutputWidth => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[39], :convention=>:stdcall  ),
        :SetOutputWidth => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[40], :convention=>:stdcall  ),
        :GetOutputLinePrefix => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[41], :convention=>:stdcall  ),
        :SetOutputLinePrefix => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[42], :convention=>:stdcall  ),
        :GetIdentity => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[43], :convention=>:stdcall  ),
        :OutputIdentity => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PCSTR], @vtable[44], :convention=>:stdcall  ),
        :GetEventCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_EVENT_CALLBACKS], @vtable[45], :convention=>:stdcall  ),
        :SetEventCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_EVENT_CALLBACKS], @vtable[46], :convention=>:stdcall  ),
        :FlushCallbacks => FFI::Function.new( HRESULT, [THIS_], @vtable[47], :convention=>:stdcall  ),
        :WriteDumpFile2 => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG, ULONG, PCSTR], @vtable[48], :convention=>:stdcall  ),
        :AddDumpInformationFile => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG], @vtable[49], :convention=>:stdcall  ),
        :EndProcessServer => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[50], :convention=>:stdcall  ),
        :WaitForProcessServerEnd => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[51], :convention=>:stdcall  ),
        :IsKernelDebuggerEnabled => FFI::Function.new( HRESULT, [THIS_], @vtable[52], :convention=>:stdcall  ),
        :TerminateCurrentProcess => FFI::Function.new( HRESULT, [THIS_], @vtable[53], :convention=>:stdcall  ),
        :DetachCurrentProcess => FFI::Function.new( HRESULT, [THIS_], @vtable[54], :convention=>:stdcall  ),
        :AbandonCurrentProcess => FFI::Function.new( HRESULT, [THIS_], @vtable[55], :convention=>:stdcall  ),
        :GetRunningProcessSystemIdByExecutableNameWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCWSTR, ULONG, PULONG], @vtable[56], :convention=>:stdcall  ),
        :GetRunningProcessDescriptionWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, ULONG, PWSTR_OUT, ULONG, PULONG, PWSTR_OUT, ULONG, PULONG], @vtable[57], :convention=>:stdcall  ),
        :CreateProcessWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, PWSTR, ULONG], @vtable[58], :convention=>:stdcall  ),
        :CreateProcessAndAttachWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, PWSTR, ULONG, ULONG, ULONG], @vtable[59], :convention=>:stdcall  ),
        :OpenDumpFileWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, ULONG64], @vtable[60], :convention=>:stdcall  ),
        :WriteDumpFileWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, ULONG64, ULONG, ULONG, PCWSTR], @vtable[61], :convention=>:stdcall  ),
        :AddDumpInformationFileWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, ULONG64, ULONG], @vtable[62], :convention=>:stdcall  ),
        :GetNumberDumpFiles => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[63], :convention=>:stdcall  ),
        :GetDumpFile => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG, PULONG64, PULONG], @vtable[64], :convention=>:stdcall  ),
        :GetDumpFileWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PWSTR_OUT, ULONG, PULONG, PULONG64, PULONG], @vtable[65], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugClient5

    NUM_APIS = 95

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :AttachKernel => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[3], :convention=>:stdcall  ),
        :GetKernelConnectionOptions => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[4], :convention=>:stdcall  ),
        :SetKernelConnectionOptions => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[5], :convention=>:stdcall  ),
        :StartProcessServer => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, PVOID], @vtable[6], :convention=>:stdcall  ),
        :ConnectProcessServer => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG64], @vtable[7], :convention=>:stdcall  ),
        :DisconnectProcessServer => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[8], :convention=>:stdcall  ),
        :GetRunningProcessSystemIds => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG, ULONG, PULONG], @vtable[9], :convention=>:stdcall  ),
        :GetRunningProcessSystemIdByExecutableName => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCSTR, ULONG, PULONG], @vtable[10], :convention=>:stdcall  ),
        :GetRunningProcessDescription => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, ULONG, PSTR_OUT, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[11], :convention=>:stdcall  ),
        :AttachProcess => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, ULONG], @vtable[12], :convention=>:stdcall  ),
        :CreateProcess => FFI::Function.new( HRESULT, [THIS_, ULONG64, PSTR, ULONG], @vtable[13], :convention=>:stdcall  ),
        :CreateProcessAndAttach => FFI::Function.new( HRESULT, [THIS_, ULONG64, PSTR, ULONG, ULONG, ULONG], @vtable[14], :convention=>:stdcall  ),
        :GetProcessOptions => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[15], :convention=>:stdcall  ),
        :AddProcessOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[16], :convention=>:stdcall  ),
        :RemoveProcessOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[17], :convention=>:stdcall  ),
        :SetProcessOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[18], :convention=>:stdcall  ),
        :OpenDumpFile => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[19], :convention=>:stdcall  ),
        :WriteDumpFile => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG], @vtable[20], :convention=>:stdcall  ),
        :ConnectSession => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[21], :convention=>:stdcall  ),
        :StartServer => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[22], :convention=>:stdcall  ),
        :OutputServers => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ULONG], @vtable[23], :convention=>:stdcall  ),
        :TerminateProcesses => FFI::Function.new( HRESULT, [THIS_], @vtable[24], :convention=>:stdcall  ),
        :DetachProcesses => FFI::Function.new( HRESULT, [THIS_], @vtable[25], :convention=>:stdcall  ),
        :EndSession => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[26], :convention=>:stdcall  ),
        :GetExitCode => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[27], :convention=>:stdcall  ),
        :DispatchCallbacks => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[28], :convention=>:stdcall  ),
        :ExitDispatch => FFI::Function.new( HRESULT, [THIS_, PDEBUG_CLIENT], @vtable[29], :convention=>:stdcall  ),
        :CreateClient => FFI::Function.new( HRESULT, [THIS_, PDEBUG_CLIENT], @vtable[30], :convention=>:stdcall  ),
        :GetInputCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_INPUT_CALLBACKS], @vtable[31], :convention=>:stdcall  ),
        :SetInputCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_INPUT_CALLBACKS], @vtable[32], :convention=>:stdcall  ),
        :GetOutputCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_OUTPUT_CALLBACKS], @vtable[33], :convention=>:stdcall  ),
        :SetOutputCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_OUTPUT_CALLBACKS], @vtable[34], :convention=>:stdcall  ),
        :GetOutputMask => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[35], :convention=>:stdcall  ),
        :SetOutputMask => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[36], :convention=>:stdcall  ),
        :GetOtherOutputMask => FFI::Function.new( HRESULT, [THIS_, PDEBUG_CLIENT, PULONG], @vtable[37], :convention=>:stdcall  ),
        :SetOtherOutputMask => FFI::Function.new( HRESULT, [THIS_, PDEBUG_CLIENT, ULONG], @vtable[38], :convention=>:stdcall  ),
        :GetOutputWidth => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[39], :convention=>:stdcall  ),
        :SetOutputWidth => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[40], :convention=>:stdcall  ),
        :GetOutputLinePrefix => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[41], :convention=>:stdcall  ),
        :SetOutputLinePrefix => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[42], :convention=>:stdcall  ),
        :GetIdentity => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[43], :convention=>:stdcall  ),
        :OutputIdentity => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PCSTR], @vtable[44], :convention=>:stdcall  ),
        :GetEventCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_EVENT_CALLBACKS], @vtable[45], :convention=>:stdcall  ),
        :SetEventCallbacks => FFI::Function.new( HRESULT, [THIS_, PDEBUG_EVENT_CALLBACKS], @vtable[46], :convention=>:stdcall  ),
        :FlushCallbacks => FFI::Function.new( HRESULT, [THIS_], @vtable[47], :convention=>:stdcall  ),
        :WriteDumpFile2 => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG, ULONG, PCSTR], @vtable[48], :convention=>:stdcall  ),
        :AddDumpInformationFile => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG], @vtable[49], :convention=>:stdcall  ),
        :EndProcessServer => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[50], :convention=>:stdcall  ),
        :WaitForProcessServerEnd => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[51], :convention=>:stdcall  ),
        :IsKernelDebuggerEnabled => FFI::Function.new( HRESULT, [THIS_], @vtable[52], :convention=>:stdcall  ),
        :TerminateCurrentProcess => FFI::Function.new( HRESULT, [THIS_], @vtable[53], :convention=>:stdcall  ),
        :DetachCurrentProcess => FFI::Function.new( HRESULT, [THIS_], @vtable[54], :convention=>:stdcall  ),
        :AbandonCurrentProcess => FFI::Function.new( HRESULT, [THIS_], @vtable[55], :convention=>:stdcall  ),
        :GetRunningProcessSystemIdByExecutableNameWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCWSTR, ULONG, PULONG], @vtable[56], :convention=>:stdcall  ),
        :GetRunningProcessDescriptionWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, ULONG, PWSTR_OUT, ULONG, PULONG, PWSTR_OUT, ULONG, PULONG], @vtable[57], :convention=>:stdcall  ),
        :CreateProcessWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, PWSTR, ULONG], @vtable[58], :convention=>:stdcall  ),
        :CreateProcessAndAttachWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, PWSTR, ULONG, ULONG, ULONG], @vtable[59], :convention=>:stdcall  ),
        :OpenDumpFileWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, ULONG64], @vtable[60], :convention=>:stdcall  ),
        :WriteDumpFileWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, ULONG64, ULONG, ULONG, PCWSTR], @vtable[61], :convention=>:stdcall  ),
        :AddDumpInformationFileWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, ULONG64, ULONG], @vtable[62], :convention=>:stdcall  ),
        :GetNumberDumpFiles => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[63], :convention=>:stdcall  ),
        :GetDumpFile => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG, PULONG64, PULONG], @vtable[64], :convention=>:stdcall  ),
        :GetDumpFileWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PWSTR_OUT, ULONG, PULONG, PULONG64, PULONG], @vtable[65], :convention=>:stdcall  ),
        :AttachKernelWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PCWSTR], @vtable[66], :convention=>:stdcall  ),
        :GetKernelConnectionOptionsWide => FFI::Function.new( HRESULT, [THIS_, PWSTR_OUT, ULONG, PULONG], @vtable[67], :convention=>:stdcall  ),
        :SetKernelConnectionOptionsWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR], @vtable[68], :convention=>:stdcall  ),
        :StartProcessServerWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PCWSTR, PVOID], @vtable[69], :convention=>:stdcall  ),
        :ConnectProcessServerWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, PULONG64], @vtable[70], :convention=>:stdcall  ),
        :StartServerWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR], @vtable[71], :convention=>:stdcall  ),
        :OutputServersWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PCWSTR, ULONG], @vtable[72], :convention=>:stdcall  ),
        :GetOutputCallbacksWide => FFI::Function.new( HRESULT, [THIS_, PDEBUG_OUTPUT_CALLBACKS_WIDE], @vtable[73], :convention=>:stdcall  ),
        :SetOutputCallbacksWide => FFI::Function.new( HRESULT, [THIS_, PDEBUG_OUTPUT_CALLBACKS_WIDE], @vtable[74], :convention=>:stdcall  ),
        :GetOutputLinePrefixWide => FFI::Function.new( HRESULT, [THIS_, PWSTR_OUT, ULONG, PULONG], @vtable[75], :convention=>:stdcall  ),
        :SetOutputLinePrefixWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR], @vtable[76], :convention=>:stdcall  ),
        :GetIdentityWide => FFI::Function.new( HRESULT, [THIS_, PWSTR_OUT, ULONG, PULONG], @vtable[77], :convention=>:stdcall  ),
        :OutputIdentityWide => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PCWSTR], @vtable[78], :convention=>:stdcall  ),
        :GetEventCallbacksWide => FFI::Function.new( HRESULT, [THIS_, PDEBUG_EVENT_CALLBACKS_WIDE], @vtable[79], :convention=>:stdcall  ),
        :SetEventCallbacksWide => FFI::Function.new( HRESULT, [THIS_, PDEBUG_EVENT_CALLBACKS_WIDE], @vtable[80], :convention=>:stdcall  ),
        :CreateProcess2 => FFI::Function.new( HRESULT, [THIS_, ULONG64, PSTR, PVOID, ULONG, PCSTR, PCSTR], @vtable[81], :convention=>:stdcall  ),
        :CreateProcess2Wide => FFI::Function.new( HRESULT, [THIS_, ULONG64, PWSTR, PVOID, ULONG, PCWSTR, PCWSTR], @vtable[82], :convention=>:stdcall  ),
        :CreateProcessAndAttach2 => FFI::Function.new( HRESULT, [THIS_, ULONG64, PSTR, PVOID, ULONG, PCSTR, PCSTR, ULONG, ULONG], @vtable[83], :convention=>:stdcall  ),
        :CreateProcessAndAttach2Wide => FFI::Function.new( HRESULT, [THIS_, ULONG64, PWSTR, PVOID, ULONG, PCWSTR, PCWSTR, ULONG, ULONG], @vtable[84], :convention=>:stdcall  ),
        :PushOutputLinePrefix => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG64], @vtable[85], :convention=>:stdcall  ),
        :PushOutputLinePrefixWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, PULONG64], @vtable[86], :convention=>:stdcall  ),
        :PopOutputLinePrefix => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[87], :convention=>:stdcall  ),
        :GetNumberInputCallbacks => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[88], :convention=>:stdcall  ),
        :GetNumberOutputCallbacks => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[89], :convention=>:stdcall  ),
        :GetNumberEventCallbacks => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG], @vtable[90], :convention=>:stdcall  ),
        :GetQuitLockString => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[91], :convention=>:stdcall  ),
        :SetQuitLockString => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[92], :convention=>:stdcall  ),
        :GetQuitLockStringWide => FFI::Function.new( HRESULT, [THIS_, PWSTR_OUT, ULONG, PULONG], @vtable[93], :convention=>:stdcall  ),
        :SetQuitLockStringWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR], @vtable[94], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugControl

    DEBUG_STATUS_NO_CHANGE                   = 0
    DEBUG_STATUS_GO                          = 1
    DEBUG_STATUS_GO_HANDLED                  = 2
    DEBUG_STATUS_GO_NOT_HANDLED              = 3
    DEBUG_STATUS_STEP_OVER                   = 4
    DEBUG_STATUS_STEP_INTO                   = 5
    DEBUG_STATUS_BREAK                       = 6
    DEBUG_STATUS_NO_DEBUGGEE                 = 7
    DEBUG_STATUS_STEP_BRANCH                 = 8
    DEBUG_STATUS_IGNORE_EVENT                = 9
    DEBUG_STATUS_RESTART_REQUESTED           = 10
    DEBUG_STATUS_REVERSE_GO                  = 11
    DEBUG_STATUS_REVERSE_STEP_BRANCH         = 12
    DEBUG_STATUS_REVERSE_STEP_OVER           = 13
    DEBUG_STATUS_REVERSE_STEP_INTO           = 14
    DEBUG_STATUS_MASK                        = 0xf
    DEBUG_STATUS_INSIDE_WAIT                 = 0x100000000
    DEBUG_STATUS_WAIT_TIMEOUT                = 0x200000000
    DEBUG_OUTCTL_THIS_CLIENT                 = 0x00000000
    DEBUG_OUTCTL_ALL_CLIENTS                 = 0x00000001
    DEBUG_OUTCTL_ALL_OTHER_CLIENTS           = 0x00000002
    DEBUG_OUTCTL_IGNORE                      = 0x00000003
    DEBUG_OUTCTL_LOG_ONLY                    = 0x00000004
    DEBUG_OUTCTL_SEND_MASK                   = 0x00000007
    DEBUG_OUTCTL_NOT_LOGGED                  = 0x00000008
    DEBUG_OUTCTL_OVERRIDE_MASK               = 0x00000010
    DEBUG_OUTCTL_DML                         = 0x00000020
    DEBUG_OUTCTL_AMBIENT_DML                 = 0xfffffffe
    DEBUG_OUTCTL_AMBIENT_TEXT                = 0xffffffff
    DEBUG_OUTCTL_AMBIENT                     = DEBUG_OUTCTL_AMBIENT_TEXT
    DEBUG_INTERRUPT_ACTIVE                   = 0
    DEBUG_INTERRUPT_PASSIVE                  = 1
    DEBUG_INTERRUPT_EXIT                     = 2
    DEBUG_CURRENT_DEFAULT                    = 0x0000000f
    DEBUG_CURRENT_SYMBOL                     = 0x00000001
    DEBUG_CURRENT_DISASM                     = 0x00000002
    DEBUG_CURRENT_REGISTERS                  = 0x00000004
    DEBUG_CURRENT_SOURCE_LINE                = 0x00000008
    DEBUG_DISASM_EFFECTIVE_ADDRESS           = 0x00000001
    DEBUG_DISASM_MATCHING_SYMBOLS            = 0x00000002
    DEBUG_DISASM_SOURCE_LINE_NUMBER          = 0x00000004
    DEBUG_DISASM_SOURCE_FILE_NAME            = 0x00000008
    DEBUG_LEVEL_SOURCE                       = 0
    DEBUG_LEVEL_ASSEMBLY                     = 1
    DEBUG_ENGOPT_IGNORE_DBGHELP_VERSION      = 0x00000001
    DEBUG_ENGOPT_IGNORE_EXTENSION_VERSIONS   = 0x00000002
    DEBUG_ENGOPT_ALLOW_NETWORK_PATHS         = 0x00000004
    DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS      = 0x00000008
    DEBUG_ENGOPT_NETWORK_PATHS               = (0x00000004 | 0x00000008)
    DEBUG_ENGOPT_IGNORE_LOADER_EXCEPTIONS    = 0x00000010
    DEBUG_ENGOPT_INITIAL_BREAK               = 0x00000020
    DEBUG_ENGOPT_INITIAL_MODULE_BREAK        = 0x00000040
    DEBUG_ENGOPT_FINAL_BREAK                 = 0x00000080
    DEBUG_ENGOPT_NO_EXECUTE_REPEAT           = 0x00000100
    DEBUG_ENGOPT_FAIL_INCOMPLETE_INFORMATION = 0x00000200
    DEBUG_ENGOPT_ALLOW_READ_ONLY_BREAKPOINTS = 0x00000400
    DEBUG_ENGOPT_SYNCHRONIZE_BREAKPOINTS     = 0x00000800
    DEBUG_ENGOPT_DISALLOW_SHELL_COMMANDS     = 0x00001000
    DEBUG_ENGOPT_KD_QUIET_MODE               = 0x00002000
    DEBUG_ENGOPT_DISABLE_MANAGED_SUPPORT     = 0x00004000
    DEBUG_ENGOPT_DISABLE_MODULE_SYMBOL_LOAD  = 0x00008000
    DEBUG_ENGOPT_DISABLE_EXECUTION_COMMANDS  = 0x00010000
    DEBUG_ENGOPT_DISALLOW_IMAGE_FILE_MAPPING = 0x00020000
    DEBUG_ENGOPT_PREFER_DML                  = 0x00040000
    DEBUG_ENGOPT_ALL                         = 0x0007FFFF
    DEBUG_ANY_ID                             = 0xffffffff
    DEBUG_STACK_ARGUMENTS                    = 0x00000001
    DEBUG_STACK_FUNCTION_INFO                = 0x00000002
    DEBUG_STACK_SOURCE_LINE                  = 0x00000004
    DEBUG_STACK_FRAME_ADDRESSES              = 0x00000008
    DEBUG_STACK_COLUMN_NAMES                 = 0x00000010
    DEBUG_STACK_NONVOLATILE_REGISTERS        = 0x00000020
    DEBUG_STACK_FRAME_NUMBERS                = 0x00000040
    DEBUG_STACK_PARAMETERS                   = 0x00000080
    DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY      = 0x00000100
    DEBUG_STACK_FRAME_MEMORY_USAGE           = 0x00000200
    DEBUG_STACK_PARAMETERS_NEWLINE           = 0x00000400
    DEBUG_STACK_DML                          = 0x00000800
    DEBUG_STACK_FRAME_OFFSETS                = 0x00001000
    DEBUG_CLASS_UNINITIALIZED                = 0
    DEBUG_CLASS_KERNEL                       = 1
    DEBUG_CLASS_USER_WINDOWS                 = 2
    DEBUG_CLASS_IMAGE_FILE                   = 3
    DEBUG_DUMP_SMALL                         = 1024
    DEBUG_DUMP_DEFAULT                       = 1025
    DEBUG_DUMP_FULL                          = 1026
    DEBUG_DUMP_IMAGE_FILE                    = 1027
    DEBUG_DUMP_TRACE_LOG                     = 1028
    DEBUG_DUMP_WINDOWS_CE                    = 1029
    DEBUG_KERNEL_CONNECTION                  = 0
    DEBUG_KERNEL_LOCAL                       = 1
    DEBUG_KERNEL_EXDI_DRIVER                 = 2
    DEBUG_KERNEL_IDNA                        = 3
    DEBUG_KERNEL_INSTALL_DRIVER              = 4
    DEBUG_KERNEL_SMALL_DUMP                  = DEBUG_DUMP_SMALL
    DEBUG_KERNEL_DUMP                        = DEBUG_DUMP_DEFAULT
    DEBUG_KERNEL_FULL_DUMP                   = DEBUG_DUMP_FULL
    DEBUG_KERNEL_TRACE_LOG                   = DEBUG_DUMP_TRACE_LOG
    DEBUG_USER_WINDOWS_PROCESS               = 0
    DEBUG_USER_WINDOWS_PROCESS_SERVER        = 1
    DEBUG_USER_WINDOWS_IDNA                  = 2
    DEBUG_USER_WINDOWS_SMALL_DUMP            = DEBUG_DUMP_SMALL
    DEBUG_USER_WINDOWS_DUMP                  = DEBUG_DUMP_DEFAULT
    DEBUG_USER_WINDOWS_DUMP_WINDOWS_CE       = DEBUG_DUMP_WINDOWS_CE
    DEBUG_EXTENSION_AT_ENGINE                = 0x00000000
    DEBUG_EXECUTE_DEFAULT                    = 0x00000000
    DEBUG_EXECUTE_ECHO                       = 0x00000001
    DEBUG_EXECUTE_NOT_LOGGED                 = 0x00000002
    DEBUG_EXECUTE_NO_REPEAT                  = 0x00000004
    DEBUG_FILTER_CREATE_THREAD               = 0x00000000
    DEBUG_FILTER_EXIT_THREAD                 = 0x00000001
    DEBUG_FILTER_CREATE_PROCESS              = 0x00000002
    DEBUG_FILTER_EXIT_PROCESS                = 0x00000003
    DEBUG_FILTER_LOAD_MODULE                 = 0x00000004
    DEBUG_FILTER_UNLOAD_MODULE               = 0x00000005
    DEBUG_FILTER_SYSTEM_ERROR                = 0x00000006
    DEBUG_FILTER_INITIAL_BREAKPOINT          = 0x00000007
    DEBUG_FILTER_INITIAL_MODULE_LOAD         = 0x00000008
    DEBUG_FILTER_DEBUGGEE_OUTPUT             = 0x00000009
    DEBUG_FILTER_BREAK                       = 0x00000000
    DEBUG_FILTER_SECOND_CHANCE_BREAK         = 0x00000001
    DEBUG_FILTER_OUTPUT                      = 0x00000002
    DEBUG_FILTER_IGNORE                      = 0x00000003
    DEBUG_FILTER_REMOVE                      = 0x00000004
    DEBUG_FILTER_GO_HANDLED                  = 0x00000000
    DEBUG_FILTER_GO_NOT_HANDLED              = 0x00000001
    DEBUG_WAIT_DEFAULT                       = 0x00000000
    DEBUG_VALUE_INVALID                      = 0
    DEBUG_VALUE_INT8                         = 1
    DEBUG_VALUE_INT16                        = 2
    DEBUG_VALUE_INT32                        = 3
    DEBUG_VALUE_INT64                        = 4
    DEBUG_VALUE_FLOAT32                      = 5
    DEBUG_VALUE_FLOAT64                      = 6
    DEBUG_VALUE_FLOAT80                      = 7
    DEBUG_VALUE_FLOAT82                      = 8
    DEBUG_VALUE_FLOAT128                     = 9
    DEBUG_VALUE_VECTOR64                     = 10
    DEBUG_VALUE_VECTOR128                    = 11
    DEBUG_VALUE_TYPES                        = 12

    NUM_APIS = 95

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :GetInterrupt => FFI::Function.new( HRESULT, [THIS_], @vtable[3], :convention=>:stdcall  ),
        :SetInterrupt => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[4], :convention=>:stdcall  ),
        :GetInterruptTimeout => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[5], :convention=>:stdcall  ),
        :SetInterruptTimeout => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[6], :convention=>:stdcall  ),
        :GetLogFile => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG, PBOOL], @vtable[7], :convention=>:stdcall  ),
        :OpenLogFile => FFI::Function.new( HRESULT, [THIS_, PCSTR, BOOL], @vtable[8], :convention=>:stdcall  ),
        :CloseLogFile => FFI::Function.new( HRESULT, [THIS_], @vtable[9], :convention=>:stdcall  ),
        :GetLogMask => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[10], :convention=>:stdcall  ),
        :SetLogMask => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[11], :convention=>:stdcall  ),
        :Input => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[12], :convention=>:stdcall  ),
        :ReturnInput => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[13], :convention=>:stdcall  ),
        :Output => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ], @vtable[14], :convention=>:stdcall  ),
        :OutputVaList => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, PVA_LIST], @vtable[15], :convention=>:stdcall  ),
        :ControlledOutput => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PCSTR, ], @vtable[16], :convention=>:stdcall  ),
        :ControlledOutputVaList => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PCSTR, PVA_LIST], @vtable[17], :convention=>:stdcall  ),
        :OutputPrompt => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ], @vtable[18], :convention=>:stdcall  ),
        :OutputPromptVaList => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, PVA_LIST], @vtable[19], :convention=>:stdcall  ),
        :GetPromptText => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[20], :convention=>:stdcall  ),
        :OutputCurrentState => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[21], :convention=>:stdcall  ),
        :OutputVersionInformation => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[22], :convention=>:stdcall  ),
        :GetNotifyEventHandle => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[23], :convention=>:stdcall  ),
        :SetNotifyEventHandle => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[24], :convention=>:stdcall  ),
        :Assemble => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCSTR, PULONG64], @vtable[25], :convention=>:stdcall  ),
        :Disassemble => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PSTR_OUT, ULONG, PULONG, PULONG64], @vtable[26], :convention=>:stdcall  ),
        :GetDisassembleEffectiveOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[27], :convention=>:stdcall  ),
        :OutputDisassembly => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, ULONG, PULONG64], @vtable[28], :convention=>:stdcall  ),
        :OutputDisassemblyLines => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG, ULONG64, ULONG, PULONG, PULONG64, PULONG64, PULONG64], @vtable[29], :convention=>:stdcall  ),
        :GetNearInstruction => FFI::Function.new( HRESULT, [THIS_, ULONG64, LONG, PULONG64], @vtable[30], :convention=>:stdcall  ),
        :GetStackTrace => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG64, PDEBUG_STACK_FRAME, ULONG, PULONG], @vtable[31], :convention=>:stdcall  ),
        :GetReturnOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[32], :convention=>:stdcall  ),
        :OutputStackTrace => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_STACK_FRAME, ULONG, ULONG], @vtable[33], :convention=>:stdcall  ),
        :GetDebuggeeType => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG], @vtable[34], :convention=>:stdcall  ),
        :GetActualProcessorType => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[35], :convention=>:stdcall  ),
        :GetExecutingProcessorType => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[36], :convention=>:stdcall  ),
        :GetNumberPossibleExecutingProcessorTypes => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[37], :convention=>:stdcall  ),
        :GetPossibleExecutingProcessorTypes => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG], @vtable[38], :convention=>:stdcall  ),
        :GetNumberProcessors => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[39], :convention=>:stdcall  ),
        :GetSystemVersion => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG, PULONG, PSTR_OUT, ULONG, PULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[40], :convention=>:stdcall  ),
        :GetPageSize => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[41], :convention=>:stdcall  ),
        :IsPointer64Bit => FFI::Function.new( HRESULT, [THIS_], @vtable[42], :convention=>:stdcall  ),
        :ReadBugCheckData => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG64, PULONG64, PULONG64, PULONG64], @vtable[43], :convention=>:stdcall  ),
        :GetNumberSupportedProcessorTypes => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[44], :convention=>:stdcall  ),
        :GetSupportedProcessorTypes => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG], @vtable[45], :convention=>:stdcall  ),
        :GetProcessorTypeNames => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[46], :convention=>:stdcall  ),
        :GetEffectiveProcessorType => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[47], :convention=>:stdcall  ),
        :SetEffectiveProcessorType => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[48], :convention=>:stdcall  ),
        :GetExecutionStatus => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[49], :convention=>:stdcall  ),
        :SetExecutionStatus => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[50], :convention=>:stdcall  ),
        :GetCodeLevel => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[51], :convention=>:stdcall  ),
        :SetCodeLevel => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[52], :convention=>:stdcall  ),
        :GetEngineOptions => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[53], :convention=>:stdcall  ),
        :AddEngineOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[54], :convention=>:stdcall  ),
        :RemoveEngineOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[55], :convention=>:stdcall  ),
        :SetEngineOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[56], :convention=>:stdcall  ),
        :GetSystemErrorControl => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG], @vtable[57], :convention=>:stdcall  ),
        :SetSystemErrorControl => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[58], :convention=>:stdcall  ),
        :GetTextMacro => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[59], :convention=>:stdcall  ),
        :SetTextMacro => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[60], :convention=>:stdcall  ),
        :GetRadix => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[61], :convention=>:stdcall  ),
        :SetRadix => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[62], :convention=>:stdcall  ),
        :Evaluate => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG, PDEBUG_VALUE, PULONG], @vtable[63], :convention=>:stdcall  ),
        :CoerceValue => FFI::Function.new( HRESULT, [THIS_, PDEBUG_VALUE, ULONG, PDEBUG_VALUE], @vtable[64], :convention=>:stdcall  ),
        :CoerceValues => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_VALUE, PULONG, PDEBUG_VALUE], @vtable[65], :convention=>:stdcall  ),
        :Execute => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ULONG], @vtable[66], :convention=>:stdcall  ),
        :ExecuteCommandFile => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ULONG], @vtable[67], :convention=>:stdcall  ),
        :GetNumberBreakpoints => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[68], :convention=>:stdcall  ),
        :GetBreakpointByIndex => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_BREAKPOINT], @vtable[69], :convention=>:stdcall  ),
        :GetBreakpointById => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_BREAKPOINT], @vtable[70], :convention=>:stdcall  ),
        :GetBreakpointParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG, ULONG, PDEBUG_BREAKPOINT_PARAMETERS], @vtable[71], :convention=>:stdcall  ),
        :AddBreakpoint => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PDEBUG_BREAKPOINT], @vtable[72], :convention=>:stdcall  ),
        :RemoveBreakpoint => FFI::Function.new( HRESULT, [THIS_, PDEBUG_BREAKPOINT], @vtable[73], :convention=>:stdcall  ),
        :AddExtension => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG, PULONG64], @vtable[74], :convention=>:stdcall  ),
        :RemoveExtension => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[75], :convention=>:stdcall  ),
        :GetExtensionByPath => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG64], @vtable[76], :convention=>:stdcall  ),
        :CallExtension => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCSTR, PCSTR], @vtable[77], :convention=>:stdcall  ),
        :GetExtensionFunction => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCSTR, FARPROC], @vtable[78], :convention=>:stdcall  ),
        :GetWindbgExtensionApis32 => FFI::Function.new( HRESULT, [THIS_, PWINDBG_EXTENSION_APIS32], @vtable[79], :convention=>:stdcall  ),
        :GetWindbgExtensionApis64 => FFI::Function.new( HRESULT, [THIS_, PWINDBG_EXTENSION_APIS64], @vtable[80], :convention=>:stdcall  ),
        :GetNumberEventFilters => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG, PULONG], @vtable[81], :convention=>:stdcall  ),
        :GetEventFilterText => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[82], :convention=>:stdcall  ),
        :GetEventFilterCommand => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[83], :convention=>:stdcall  ),
        :SetEventFilterCommand => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[84], :convention=>:stdcall  ),
        :GetSpecificFilterParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PDEBUG_SPECIFIC_FILTER_PARAMETERS], @vtable[85], :convention=>:stdcall  ),
        :SetSpecificFilterParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PDEBUG_SPECIFIC_FILTER_PARAMETERS], @vtable[86], :convention=>:stdcall  ),
        :GetSpecificFilterArgument => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[87], :convention=>:stdcall  ),
        :SetSpecificFilterArgument => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[88], :convention=>:stdcall  ),
        :GetExceptionFilterParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG, ULONG, PDEBUG_EXCEPTION_FILTER_PARAMETERS], @vtable[89], :convention=>:stdcall  ),
        :SetExceptionFilterParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_EXCEPTION_FILTER_PARAMETERS], @vtable[90], :convention=>:stdcall  ),
        :GetExceptionFilterSecondCommand => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[91], :convention=>:stdcall  ),
        :SetExceptionFilterSecondCommand => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[92], :convention=>:stdcall  ),
        :WaitForEvent => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[93], :convention=>:stdcall  ),
        :GetLastEventInformation => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG, PULONG, PVOID, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[94], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugControl2

    DEBUG_OUT_TEXT_REPL_DEFAULT = 0x00000000

    NUM_APIS = 103

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :GetInterrupt => FFI::Function.new( HRESULT, [THIS_], @vtable[3], :convention=>:stdcall  ),
        :SetInterrupt => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[4], :convention=>:stdcall  ),
        :GetInterruptTimeout => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[5], :convention=>:stdcall  ),
        :SetInterruptTimeout => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[6], :convention=>:stdcall  ),
        :GetLogFile => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG, PBOOL], @vtable[7], :convention=>:stdcall  ),
        :OpenLogFile => FFI::Function.new( HRESULT, [THIS_, PCSTR, BOOL], @vtable[8], :convention=>:stdcall  ),
        :CloseLogFile => FFI::Function.new( HRESULT, [THIS_], @vtable[9], :convention=>:stdcall  ),
        :GetLogMask => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[10], :convention=>:stdcall  ),
        :SetLogMask => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[11], :convention=>:stdcall  ),
        :Input => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[12], :convention=>:stdcall  ),
        :ReturnInput => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[13], :convention=>:stdcall  ),
        :Output => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ], @vtable[14], :convention=>:stdcall  ),
        :OutputVaList => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, PVA_LIST], @vtable[15], :convention=>:stdcall  ),
        :ControlledOutput => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PCSTR, ], @vtable[16], :convention=>:stdcall  ),
        :ControlledOutputVaList => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PCSTR, PVA_LIST], @vtable[17], :convention=>:stdcall  ),
        :OutputPrompt => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ], @vtable[18], :convention=>:stdcall  ),
        :OutputPromptVaList => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, PVA_LIST], @vtable[19], :convention=>:stdcall  ),
        :GetPromptText => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[20], :convention=>:stdcall  ),
        :OutputCurrentState => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[21], :convention=>:stdcall  ),
        :OutputVersionInformation => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[22], :convention=>:stdcall  ),
        :GetNotifyEventHandle => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[23], :convention=>:stdcall  ),
        :SetNotifyEventHandle => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[24], :convention=>:stdcall  ),
        :Assemble => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCSTR, PULONG64], @vtable[25], :convention=>:stdcall  ),
        :Disassemble => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PSTR_OUT, ULONG, PULONG, PULONG64], @vtable[26], :convention=>:stdcall  ),
        :GetDisassembleEffectiveOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[27], :convention=>:stdcall  ),
        :OutputDisassembly => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, ULONG, PULONG64], @vtable[28], :convention=>:stdcall  ),
        :OutputDisassemblyLines => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG, ULONG64, ULONG, PULONG, PULONG64, PULONG64, PULONG64], @vtable[29], :convention=>:stdcall  ),
        :GetNearInstruction => FFI::Function.new( HRESULT, [THIS_, ULONG64, LONG, PULONG64], @vtable[30], :convention=>:stdcall  ),
        :GetStackTrace => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG64, PDEBUG_STACK_FRAME, ULONG, PULONG], @vtable[31], :convention=>:stdcall  ),
        :GetReturnOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[32], :convention=>:stdcall  ),
        :OutputStackTrace => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_STACK_FRAME, ULONG, ULONG], @vtable[33], :convention=>:stdcall  ),
        :GetDebuggeeType => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG], @vtable[34], :convention=>:stdcall  ),
        :GetActualProcessorType => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[35], :convention=>:stdcall  ),
        :GetExecutingProcessorType => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[36], :convention=>:stdcall  ),
        :GetNumberPossibleExecutingProcessorTypes => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[37], :convention=>:stdcall  ),
        :GetPossibleExecutingProcessorTypes => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG], @vtable[38], :convention=>:stdcall  ),
        :GetNumberProcessors => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[39], :convention=>:stdcall  ),
        :GetSystemVersion => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG, PULONG, PSTR_OUT, ULONG, PULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[40], :convention=>:stdcall  ),
        :GetPageSize => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[41], :convention=>:stdcall  ),
        :IsPointer64Bit => FFI::Function.new( HRESULT, [THIS_], @vtable[42], :convention=>:stdcall  ),
        :ReadBugCheckData => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG64, PULONG64, PULONG64, PULONG64], @vtable[43], :convention=>:stdcall  ),
        :GetNumberSupportedProcessorTypes => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[44], :convention=>:stdcall  ),
        :GetSupportedProcessorTypes => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG], @vtable[45], :convention=>:stdcall  ),
        :GetProcessorTypeNames => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[46], :convention=>:stdcall  ),
        :GetEffectiveProcessorType => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[47], :convention=>:stdcall  ),
        :SetEffectiveProcessorType => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[48], :convention=>:stdcall  ),
        :GetExecutionStatus => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[49], :convention=>:stdcall  ),
        :SetExecutionStatus => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[50], :convention=>:stdcall  ),
        :GetCodeLevel => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[51], :convention=>:stdcall  ),
        :SetCodeLevel => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[52], :convention=>:stdcall  ),
        :GetEngineOptions => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[53], :convention=>:stdcall  ),
        :AddEngineOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[54], :convention=>:stdcall  ),
        :RemoveEngineOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[55], :convention=>:stdcall  ),
        :SetEngineOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[56], :convention=>:stdcall  ),
        :GetSystemErrorControl => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG], @vtable[57], :convention=>:stdcall  ),
        :SetSystemErrorControl => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[58], :convention=>:stdcall  ),
        :GetTextMacro => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[59], :convention=>:stdcall  ),
        :SetTextMacro => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[60], :convention=>:stdcall  ),
        :GetRadix => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[61], :convention=>:stdcall  ),
        :SetRadix => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[62], :convention=>:stdcall  ),
        :Evaluate => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG, PDEBUG_VALUE, PULONG], @vtable[63], :convention=>:stdcall  ),
        :CoerceValue => FFI::Function.new( HRESULT, [THIS_, PDEBUG_VALUE, ULONG, PDEBUG_VALUE], @vtable[64], :convention=>:stdcall  ),
        :CoerceValues => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_VALUE, PULONG, PDEBUG_VALUE], @vtable[65], :convention=>:stdcall  ),
        :Execute => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ULONG], @vtable[66], :convention=>:stdcall  ),
        :ExecuteCommandFile => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ULONG], @vtable[67], :convention=>:stdcall  ),
        :GetNumberBreakpoints => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[68], :convention=>:stdcall  ),
        :GetBreakpointByIndex => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_BREAKPOINT], @vtable[69], :convention=>:stdcall  ),
        :GetBreakpointById => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_BREAKPOINT], @vtable[70], :convention=>:stdcall  ),
        :GetBreakpointParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG, ULONG, PDEBUG_BREAKPOINT_PARAMETERS], @vtable[71], :convention=>:stdcall  ),
        :AddBreakpoint => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PDEBUG_BREAKPOINT], @vtable[72], :convention=>:stdcall  ),
        :RemoveBreakpoint => FFI::Function.new( HRESULT, [THIS_, PDEBUG_BREAKPOINT], @vtable[73], :convention=>:stdcall  ),
        :AddExtension => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG, PULONG64], @vtable[74], :convention=>:stdcall  ),
        :RemoveExtension => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[75], :convention=>:stdcall  ),
        :GetExtensionByPath => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG64], @vtable[76], :convention=>:stdcall  ),
        :CallExtension => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCSTR, PCSTR], @vtable[77], :convention=>:stdcall  ),
        :GetExtensionFunction => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCSTR, FARPROC], @vtable[78], :convention=>:stdcall  ),
        :GetWindbgExtensionApis32 => FFI::Function.new( HRESULT, [THIS_, PWINDBG_EXTENSION_APIS32], @vtable[79], :convention=>:stdcall  ),
        :GetWindbgExtensionApis64 => FFI::Function.new( HRESULT, [THIS_, PWINDBG_EXTENSION_APIS64], @vtable[80], :convention=>:stdcall  ),
        :GetNumberEventFilters => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG, PULONG], @vtable[81], :convention=>:stdcall  ),
        :GetEventFilterText => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[82], :convention=>:stdcall  ),
        :GetEventFilterCommand => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[83], :convention=>:stdcall  ),
        :SetEventFilterCommand => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[84], :convention=>:stdcall  ),
        :GetSpecificFilterParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PDEBUG_SPECIFIC_FILTER_PARAMETERS], @vtable[85], :convention=>:stdcall  ),
        :SetSpecificFilterParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PDEBUG_SPECIFIC_FILTER_PARAMETERS], @vtable[86], :convention=>:stdcall  ),
        :GetSpecificFilterArgument => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[87], :convention=>:stdcall  ),
        :SetSpecificFilterArgument => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[88], :convention=>:stdcall  ),
        :GetExceptionFilterParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG, ULONG, PDEBUG_EXCEPTION_FILTER_PARAMETERS], @vtable[89], :convention=>:stdcall  ),
        :SetExceptionFilterParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_EXCEPTION_FILTER_PARAMETERS], @vtable[90], :convention=>:stdcall  ),
        :GetExceptionFilterSecondCommand => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[91], :convention=>:stdcall  ),
        :SetExceptionFilterSecondCommand => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[92], :convention=>:stdcall  ),
        :WaitForEvent => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[93], :convention=>:stdcall  ),
        :GetLastEventInformation => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG, PULONG, PVOID, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[94], :convention=>:stdcall  ),
        :GetCurrentTimeDate => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[95], :convention=>:stdcall  ),
        :GetCurrentSystemUpTime => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[96], :convention=>:stdcall  ),
        :GetDumpFormatFlags => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[97], :convention=>:stdcall  ),
        :GetNumberTextReplacements => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[98], :convention=>:stdcall  ),
        :GetTextReplacement => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG, PSTR_OUT, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[99], :convention=>:stdcall  ),
        :SetTextReplacement => FFI::Function.new( HRESULT, [THIS_, PCSTR, PCSTR], @vtable[100], :convention=>:stdcall  ),
        :RemoveTextReplacements => FFI::Function.new( HRESULT, [THIS_], @vtable[101], :convention=>:stdcall  ),
        :OutputTextReplacements => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[102], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugControl3

    DEBUG_ASMOPT_DEFAULT             = 0x00000000
    DEBUG_ASMOPT_VERBOSE             = 0x00000001
    DEBUG_ASMOPT_NO_CODE_BYTES       = 0x00000002
    DEBUG_ASMOPT_IGNORE_OUTPUT_WIDTH = 0x00000004
    DEBUG_ASMOPT_SOURCE_LINE_NUMBER  = 0x00000008
    DEBUG_EXPR_MASM                  = 0x00000000
    DEBUG_EXPR_CPLUSPLUS             = 0x00000001
    DEBUG_EINDEX_NAME                = 0x00000000
    DEBUG_EINDEX_FROM_START          = 0x00000000
    DEBUG_EINDEX_FROM_END            = 0x00000001
    DEBUG_EINDEX_FROM_CURRENT        = 0x00000002

    NUM_APIS = 116

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :GetInterrupt => FFI::Function.new( HRESULT, [THIS_], @vtable[3], :convention=>:stdcall  ),
        :SetInterrupt => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[4], :convention=>:stdcall  ),
        :GetInterruptTimeout => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[5], :convention=>:stdcall  ),
        :SetInterruptTimeout => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[6], :convention=>:stdcall  ),
        :GetLogFile => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG, PBOOL], @vtable[7], :convention=>:stdcall  ),
        :OpenLogFile => FFI::Function.new( HRESULT, [THIS_, PCSTR, BOOL], @vtable[8], :convention=>:stdcall  ),
        :CloseLogFile => FFI::Function.new( HRESULT, [THIS_], @vtable[9], :convention=>:stdcall  ),
        :GetLogMask => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[10], :convention=>:stdcall  ),
        :SetLogMask => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[11], :convention=>:stdcall  ),
        :Input => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[12], :convention=>:stdcall  ),
        :ReturnInput => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[13], :convention=>:stdcall  ),
        :Output => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ], @vtable[14], :convention=>:stdcall  ),
        :OutputVaList => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, PVA_LIST], @vtable[15], :convention=>:stdcall  ),
        :ControlledOutput => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PCSTR, ], @vtable[16], :convention=>:stdcall  ),
        :ControlledOutputVaList => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PCSTR, PVA_LIST], @vtable[17], :convention=>:stdcall  ),
        :OutputPrompt => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ], @vtable[18], :convention=>:stdcall  ),
        :OutputPromptVaList => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, PVA_LIST], @vtable[19], :convention=>:stdcall  ),
        :GetPromptText => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[20], :convention=>:stdcall  ),
        :OutputCurrentState => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[21], :convention=>:stdcall  ),
        :OutputVersionInformation => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[22], :convention=>:stdcall  ),
        :GetNotifyEventHandle => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[23], :convention=>:stdcall  ),
        :SetNotifyEventHandle => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[24], :convention=>:stdcall  ),
        :Assemble => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCSTR, PULONG64], @vtable[25], :convention=>:stdcall  ),
        :Disassemble => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PSTR_OUT, ULONG, PULONG, PULONG64], @vtable[26], :convention=>:stdcall  ),
        :GetDisassembleEffectiveOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[27], :convention=>:stdcall  ),
        :OutputDisassembly => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, ULONG, PULONG64], @vtable[28], :convention=>:stdcall  ),
        :OutputDisassemblyLines => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG, ULONG64, ULONG, PULONG, PULONG64, PULONG64, PULONG64], @vtable[29], :convention=>:stdcall  ),
        :GetNearInstruction => FFI::Function.new( HRESULT, [THIS_, ULONG64, LONG, PULONG64], @vtable[30], :convention=>:stdcall  ),
        :GetStackTrace => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG64, PDEBUG_STACK_FRAME, ULONG, PULONG], @vtable[31], :convention=>:stdcall  ),
        :GetReturnOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[32], :convention=>:stdcall  ),
        :OutputStackTrace => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_STACK_FRAME, ULONG, ULONG], @vtable[33], :convention=>:stdcall  ),
        :GetDebuggeeType => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG], @vtable[34], :convention=>:stdcall  ),
        :GetActualProcessorType => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[35], :convention=>:stdcall  ),
        :GetExecutingProcessorType => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[36], :convention=>:stdcall  ),
        :GetNumberPossibleExecutingProcessorTypes => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[37], :convention=>:stdcall  ),
        :GetPossibleExecutingProcessorTypes => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG], @vtable[38], :convention=>:stdcall  ),
        :GetNumberProcessors => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[39], :convention=>:stdcall  ),
        :GetSystemVersion => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG, PULONG, PSTR_OUT, ULONG, PULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[40], :convention=>:stdcall  ),
        :GetPageSize => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[41], :convention=>:stdcall  ),
        :IsPointer64Bit => FFI::Function.new( HRESULT, [THIS_], @vtable[42], :convention=>:stdcall  ),
        :ReadBugCheckData => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG64, PULONG64, PULONG64, PULONG64], @vtable[43], :convention=>:stdcall  ),
        :GetNumberSupportedProcessorTypes => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[44], :convention=>:stdcall  ),
        :GetSupportedProcessorTypes => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG], @vtable[45], :convention=>:stdcall  ),
        :GetProcessorTypeNames => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[46], :convention=>:stdcall  ),
        :GetEffectiveProcessorType => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[47], :convention=>:stdcall  ),
        :SetEffectiveProcessorType => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[48], :convention=>:stdcall  ),
        :GetExecutionStatus => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[49], :convention=>:stdcall  ),
        :SetExecutionStatus => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[50], :convention=>:stdcall  ),
        :GetCodeLevel => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[51], :convention=>:stdcall  ),
        :SetCodeLevel => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[52], :convention=>:stdcall  ),
        :GetEngineOptions => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[53], :convention=>:stdcall  ),
        :AddEngineOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[54], :convention=>:stdcall  ),
        :RemoveEngineOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[55], :convention=>:stdcall  ),
        :SetEngineOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[56], :convention=>:stdcall  ),
        :GetSystemErrorControl => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG], @vtable[57], :convention=>:stdcall  ),
        :SetSystemErrorControl => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[58], :convention=>:stdcall  ),
        :GetTextMacro => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[59], :convention=>:stdcall  ),
        :SetTextMacro => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[60], :convention=>:stdcall  ),
        :GetRadix => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[61], :convention=>:stdcall  ),
        :SetRadix => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[62], :convention=>:stdcall  ),
        :Evaluate => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG, PDEBUG_VALUE, PULONG], @vtable[63], :convention=>:stdcall  ),
        :CoerceValue => FFI::Function.new( HRESULT, [THIS_, PDEBUG_VALUE, ULONG, PDEBUG_VALUE], @vtable[64], :convention=>:stdcall  ),
        :CoerceValues => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_VALUE, PULONG, PDEBUG_VALUE], @vtable[65], :convention=>:stdcall  ),
        :Execute => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ULONG], @vtable[66], :convention=>:stdcall  ),
        :ExecuteCommandFile => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ULONG], @vtable[67], :convention=>:stdcall  ),
        :GetNumberBreakpoints => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[68], :convention=>:stdcall  ),
        :GetBreakpointByIndex => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_BREAKPOINT], @vtable[69], :convention=>:stdcall  ),
        :GetBreakpointById => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_BREAKPOINT], @vtable[70], :convention=>:stdcall  ),
        :GetBreakpointParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG, ULONG, PDEBUG_BREAKPOINT_PARAMETERS], @vtable[71], :convention=>:stdcall  ),
        :AddBreakpoint => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PDEBUG_BREAKPOINT], @vtable[72], :convention=>:stdcall  ),
        :RemoveBreakpoint => FFI::Function.new( HRESULT, [THIS_, PDEBUG_BREAKPOINT], @vtable[73], :convention=>:stdcall  ),
        :AddExtension => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG, PULONG64], @vtable[74], :convention=>:stdcall  ),
        :RemoveExtension => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[75], :convention=>:stdcall  ),
        :GetExtensionByPath => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG64], @vtable[76], :convention=>:stdcall  ),
        :CallExtension => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCSTR, PCSTR], @vtable[77], :convention=>:stdcall  ),
        :GetExtensionFunction => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCSTR, FARPROC], @vtable[78], :convention=>:stdcall  ),
        :GetWindbgExtensionApis32 => FFI::Function.new( HRESULT, [THIS_, PWINDBG_EXTENSION_APIS32], @vtable[79], :convention=>:stdcall  ),
        :GetWindbgExtensionApis64 => FFI::Function.new( HRESULT, [THIS_, PWINDBG_EXTENSION_APIS64], @vtable[80], :convention=>:stdcall  ),
        :GetNumberEventFilters => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG, PULONG], @vtable[81], :convention=>:stdcall  ),
        :GetEventFilterText => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[82], :convention=>:stdcall  ),
        :GetEventFilterCommand => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[83], :convention=>:stdcall  ),
        :SetEventFilterCommand => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[84], :convention=>:stdcall  ),
        :GetSpecificFilterParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PDEBUG_SPECIFIC_FILTER_PARAMETERS], @vtable[85], :convention=>:stdcall  ),
        :SetSpecificFilterParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PDEBUG_SPECIFIC_FILTER_PARAMETERS], @vtable[86], :convention=>:stdcall  ),
        :GetSpecificFilterArgument => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[87], :convention=>:stdcall  ),
        :SetSpecificFilterArgument => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[88], :convention=>:stdcall  ),
        :GetExceptionFilterParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG, ULONG, PDEBUG_EXCEPTION_FILTER_PARAMETERS], @vtable[89], :convention=>:stdcall  ),
        :SetExceptionFilterParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_EXCEPTION_FILTER_PARAMETERS], @vtable[90], :convention=>:stdcall  ),
        :GetExceptionFilterSecondCommand => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[91], :convention=>:stdcall  ),
        :SetExceptionFilterSecondCommand => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[92], :convention=>:stdcall  ),
        :WaitForEvent => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[93], :convention=>:stdcall  ),
        :GetLastEventInformation => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG, PULONG, PVOID, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[94], :convention=>:stdcall  ),
        :GetCurrentTimeDate => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[95], :convention=>:stdcall  ),
        :GetCurrentSystemUpTime => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[96], :convention=>:stdcall  ),
        :GetDumpFormatFlags => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[97], :convention=>:stdcall  ),
        :GetNumberTextReplacements => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[98], :convention=>:stdcall  ),
        :GetTextReplacement => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG, PSTR_OUT, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[99], :convention=>:stdcall  ),
        :SetTextReplacement => FFI::Function.new( HRESULT, [THIS_, PCSTR, PCSTR], @vtable[100], :convention=>:stdcall  ),
        :RemoveTextReplacements => FFI::Function.new( HRESULT, [THIS_], @vtable[101], :convention=>:stdcall  ),
        :OutputTextReplacements => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[102], :convention=>:stdcall  ),
        :GetAssemblyOptions => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[103], :convention=>:stdcall  ),
        :AddAssemblyOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[104], :convention=>:stdcall  ),
        :RemoveAssemblyOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[105], :convention=>:stdcall  ),
        :SetAssemblyOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[106], :convention=>:stdcall  ),
        :GetExpressionSyntax => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[107], :convention=>:stdcall  ),
        :SetExpressionSyntax => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[108], :convention=>:stdcall  ),
        :SetExpressionSyntaxByName => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[109], :convention=>:stdcall  ),
        :GetNumberExpressionSyntaxes => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[110], :convention=>:stdcall  ),
        :GetExpressionSyntaxNames => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[111], :convention=>:stdcall  ),
        :GetNumberEvents => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[112], :convention=>:stdcall  ),
        :GetEventIndexDescription => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PSTR, ULONG, PULONG], @vtable[113], :convention=>:stdcall  ),
        :GetCurrentEventIndex => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[114], :convention=>:stdcall  ),
        :SetNextEventIndex => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG], @vtable[115], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugControl4

    DEBUG_LOG_DEFAULT               = 0x00000000
    DEBUG_LOG_APPEND                = 0x00000001
    DEBUG_LOG_UNICODE               = 0x00000002
    DEBUG_LOG_DML                   = 0x00000004
    DEBUG_SYSVERSTR_SERVICE_PACK    = 0x00000000
    DEBUG_SYSVERSTR_BUILD           = 0x00000001
    DEBUG_MANAGED_DISABLED          = 0x00000000
    DEBUG_MANAGED_ALLOWED           = 0x00000001
    DEBUG_MANAGED_DLL_LOADED        = 0x00000002
    DEBUG_MANSTR_NONE               = 0x00000000
    DEBUG_MANSTR_LOADED_SUPPORT_DLL = 0x00000001
    DEBUG_MANSTR_LOAD_STATUS        = 0x00000002
    DEBUG_MANRESET_DEFAULT          = 0x00000000
    DEBUG_MANRESET_LOAD_DLL         = 0x00000001

    NUM_APIS = 169

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :GetInterrupt => FFI::Function.new( HRESULT, [THIS_], @vtable[3], :convention=>:stdcall  ),
        :SetInterrupt => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[4], :convention=>:stdcall  ),
        :GetInterruptTimeout => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[5], :convention=>:stdcall  ),
        :SetInterruptTimeout => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[6], :convention=>:stdcall  ),
        :GetLogFile => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG, PBOOL], @vtable[7], :convention=>:stdcall  ),
        :OpenLogFile => FFI::Function.new( HRESULT, [THIS_, PCSTR, BOOL], @vtable[8], :convention=>:stdcall  ),
        :CloseLogFile => FFI::Function.new( HRESULT, [THIS_], @vtable[9], :convention=>:stdcall  ),
        :GetLogMask => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[10], :convention=>:stdcall  ),
        :SetLogMask => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[11], :convention=>:stdcall  ),
        :Input => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[12], :convention=>:stdcall  ),
        :ReturnInput => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[13], :convention=>:stdcall  ),
        :Output => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ], @vtable[14], :convention=>:stdcall  ),
        :OutputVaList => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, PVA_LIST], @vtable[15], :convention=>:stdcall  ),
        :ControlledOutput => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PCSTR, ], @vtable[16], :convention=>:stdcall  ),
        :ControlledOutputVaList => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PCSTR, PVA_LIST], @vtable[17], :convention=>:stdcall  ),
        :OutputPrompt => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ], @vtable[18], :convention=>:stdcall  ),
        :OutputPromptVaList => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, PVA_LIST], @vtable[19], :convention=>:stdcall  ),
        :GetPromptText => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[20], :convention=>:stdcall  ),
        :OutputCurrentState => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[21], :convention=>:stdcall  ),
        :OutputVersionInformation => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[22], :convention=>:stdcall  ),
        :GetNotifyEventHandle => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[23], :convention=>:stdcall  ),
        :SetNotifyEventHandle => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[24], :convention=>:stdcall  ),
        :Assemble => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCSTR, PULONG64], @vtable[25], :convention=>:stdcall  ),
        :Disassemble => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PSTR_OUT, ULONG, PULONG, PULONG64], @vtable[26], :convention=>:stdcall  ),
        :GetDisassembleEffectiveOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[27], :convention=>:stdcall  ),
        :OutputDisassembly => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, ULONG, PULONG64], @vtable[28], :convention=>:stdcall  ),
        :OutputDisassemblyLines => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG, ULONG64, ULONG, PULONG, PULONG64, PULONG64, PULONG64], @vtable[29], :convention=>:stdcall  ),
        :GetNearInstruction => FFI::Function.new( HRESULT, [THIS_, ULONG64, LONG, PULONG64], @vtable[30], :convention=>:stdcall  ),
        :GetStackTrace => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG64, PDEBUG_STACK_FRAME, ULONG, PULONG], @vtable[31], :convention=>:stdcall  ),
        :GetReturnOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[32], :convention=>:stdcall  ),
        :OutputStackTrace => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_STACK_FRAME, ULONG, ULONG], @vtable[33], :convention=>:stdcall  ),
        :GetDebuggeeType => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG], @vtable[34], :convention=>:stdcall  ),
        :GetActualProcessorType => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[35], :convention=>:stdcall  ),
        :GetExecutingProcessorType => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[36], :convention=>:stdcall  ),
        :GetNumberPossibleExecutingProcessorTypes => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[37], :convention=>:stdcall  ),
        :GetPossibleExecutingProcessorTypes => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG], @vtable[38], :convention=>:stdcall  ),
        :GetNumberProcessors => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[39], :convention=>:stdcall  ),
        :GetSystemVersion => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG, PULONG, PSTR_OUT, ULONG, PULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[40], :convention=>:stdcall  ),
        :GetPageSize => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[41], :convention=>:stdcall  ),
        :IsPointer64Bit => FFI::Function.new( HRESULT, [THIS_], @vtable[42], :convention=>:stdcall  ),
        :ReadBugCheckData => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG64, PULONG64, PULONG64, PULONG64], @vtable[43], :convention=>:stdcall  ),
        :GetNumberSupportedProcessorTypes => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[44], :convention=>:stdcall  ),
        :GetSupportedProcessorTypes => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG], @vtable[45], :convention=>:stdcall  ),
        :GetProcessorTypeNames => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[46], :convention=>:stdcall  ),
        :GetEffectiveProcessorType => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[47], :convention=>:stdcall  ),
        :SetEffectiveProcessorType => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[48], :convention=>:stdcall  ),
        :GetExecutionStatus => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[49], :convention=>:stdcall  ),
        :SetExecutionStatus => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[50], :convention=>:stdcall  ),
        :GetCodeLevel => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[51], :convention=>:stdcall  ),
        :SetCodeLevel => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[52], :convention=>:stdcall  ),
        :GetEngineOptions => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[53], :convention=>:stdcall  ),
        :AddEngineOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[54], :convention=>:stdcall  ),
        :RemoveEngineOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[55], :convention=>:stdcall  ),
        :SetEngineOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[56], :convention=>:stdcall  ),
        :GetSystemErrorControl => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG], @vtable[57], :convention=>:stdcall  ),
        :SetSystemErrorControl => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[58], :convention=>:stdcall  ),
        :GetTextMacro => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[59], :convention=>:stdcall  ),
        :SetTextMacro => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[60], :convention=>:stdcall  ),
        :GetRadix => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[61], :convention=>:stdcall  ),
        :SetRadix => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[62], :convention=>:stdcall  ),
        :Evaluate => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG, PDEBUG_VALUE, PULONG], @vtable[63], :convention=>:stdcall  ),
        :CoerceValue => FFI::Function.new( HRESULT, [THIS_, PDEBUG_VALUE, ULONG, PDEBUG_VALUE], @vtable[64], :convention=>:stdcall  ),
        :CoerceValues => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_VALUE, PULONG, PDEBUG_VALUE], @vtable[65], :convention=>:stdcall  ),
        :Execute => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ULONG], @vtable[66], :convention=>:stdcall  ),
        :ExecuteCommandFile => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ULONG], @vtable[67], :convention=>:stdcall  ),
        :GetNumberBreakpoints => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[68], :convention=>:stdcall  ),
        :GetBreakpointByIndex => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_BREAKPOINT], @vtable[69], :convention=>:stdcall  ),
        :GetBreakpointById => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_BREAKPOINT], @vtable[70], :convention=>:stdcall  ),
        :GetBreakpointParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG, ULONG, PDEBUG_BREAKPOINT_PARAMETERS], @vtable[71], :convention=>:stdcall  ),
        :AddBreakpoint => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PDEBUG_BREAKPOINT], @vtable[72], :convention=>:stdcall  ),
        :RemoveBreakpoint => FFI::Function.new( HRESULT, [THIS_, PDEBUG_BREAKPOINT], @vtable[73], :convention=>:stdcall  ),
        :AddExtension => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG, PULONG64], @vtable[74], :convention=>:stdcall  ),
        :RemoveExtension => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[75], :convention=>:stdcall  ),
        :GetExtensionByPath => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG64], @vtable[76], :convention=>:stdcall  ),
        :CallExtension => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCSTR, PCSTR], @vtable[77], :convention=>:stdcall  ),
        :GetExtensionFunction => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCSTR, FARPROC], @vtable[78], :convention=>:stdcall  ),
        :GetWindbgExtensionApis32 => FFI::Function.new( HRESULT, [THIS_, PWINDBG_EXTENSION_APIS32], @vtable[79], :convention=>:stdcall  ),
        :GetWindbgExtensionApis64 => FFI::Function.new( HRESULT, [THIS_, PWINDBG_EXTENSION_APIS64], @vtable[80], :convention=>:stdcall  ),
        :GetNumberEventFilters => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG, PULONG], @vtable[81], :convention=>:stdcall  ),
        :GetEventFilterText => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[82], :convention=>:stdcall  ),
        :GetEventFilterCommand => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[83], :convention=>:stdcall  ),
        :SetEventFilterCommand => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[84], :convention=>:stdcall  ),
        :GetSpecificFilterParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PDEBUG_SPECIFIC_FILTER_PARAMETERS], @vtable[85], :convention=>:stdcall  ),
        :SetSpecificFilterParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PDEBUG_SPECIFIC_FILTER_PARAMETERS], @vtable[86], :convention=>:stdcall  ),
        :GetSpecificFilterArgument => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[87], :convention=>:stdcall  ),
        :SetSpecificFilterArgument => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[88], :convention=>:stdcall  ),
        :GetExceptionFilterParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG, ULONG, PDEBUG_EXCEPTION_FILTER_PARAMETERS], @vtable[89], :convention=>:stdcall  ),
        :SetExceptionFilterParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_EXCEPTION_FILTER_PARAMETERS], @vtable[90], :convention=>:stdcall  ),
        :GetExceptionFilterSecondCommand => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[91], :convention=>:stdcall  ),
        :SetExceptionFilterSecondCommand => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[92], :convention=>:stdcall  ),
        :WaitForEvent => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[93], :convention=>:stdcall  ),
        :GetLastEventInformation => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG, PULONG, PVOID, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[94], :convention=>:stdcall  ),
        :GetCurrentTimeDate => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[95], :convention=>:stdcall  ),
        :GetCurrentSystemUpTime => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[96], :convention=>:stdcall  ),
        :GetDumpFormatFlags => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[97], :convention=>:stdcall  ),
        :GetNumberTextReplacements => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[98], :convention=>:stdcall  ),
        :GetTextReplacement => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG, PSTR_OUT, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[99], :convention=>:stdcall  ),
        :SetTextReplacement => FFI::Function.new( HRESULT, [THIS_, PCSTR, PCSTR], @vtable[100], :convention=>:stdcall  ),
        :RemoveTextReplacements => FFI::Function.new( HRESULT, [THIS_], @vtable[101], :convention=>:stdcall  ),
        :OutputTextReplacements => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[102], :convention=>:stdcall  ),
        :GetAssemblyOptions => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[103], :convention=>:stdcall  ),
        :AddAssemblyOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[104], :convention=>:stdcall  ),
        :RemoveAssemblyOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[105], :convention=>:stdcall  ),
        :SetAssemblyOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[106], :convention=>:stdcall  ),
        :GetExpressionSyntax => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[107], :convention=>:stdcall  ),
        :SetExpressionSyntax => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[108], :convention=>:stdcall  ),
        :SetExpressionSyntaxByName => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[109], :convention=>:stdcall  ),
        :GetNumberExpressionSyntaxes => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[110], :convention=>:stdcall  ),
        :GetExpressionSyntaxNames => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[111], :convention=>:stdcall  ),
        :GetNumberEvents => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[112], :convention=>:stdcall  ),
        :GetEventIndexDescription => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PSTR, ULONG, PULONG], @vtable[113], :convention=>:stdcall  ),
        :GetCurrentEventIndex => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[114], :convention=>:stdcall  ),
        :SetNextEventIndex => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG], @vtable[115], :convention=>:stdcall  ),
        :GetLogFileWide => FFI::Function.new( HRESULT, [THIS_, PWSTR_OUT, ULONG, PULONG, PBOOL], @vtable[116], :convention=>:stdcall  ),
        :OpenLogFileWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, BOOL], @vtable[117], :convention=>:stdcall  ),
        :InputWide => FFI::Function.new( HRESULT, [THIS_, PWSTR_OUT, ULONG, PULONG], @vtable[118], :convention=>:stdcall  ),
        :ReturnInputWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR], @vtable[119], :convention=>:stdcall  ),
        :OutputWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PCWSTR, ], @vtable[120], :convention=>:stdcall  ),
        :OutputVaListWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PCWSTR, PVA_LIST], @vtable[121], :convention=>:stdcall  ),
        :ControlledOutputWide => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PCWSTR, ], @vtable[122], :convention=>:stdcall  ),
        :ControlledOutputVaListWide => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PCWSTR, PVA_LIST], @vtable[123], :convention=>:stdcall  ),
        :OutputPromptWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PCWSTR, ], @vtable[124], :convention=>:stdcall  ),
        :OutputPromptVaListWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PCWSTR, PVA_LIST], @vtable[125], :convention=>:stdcall  ),
        :GetPromptTextWide => FFI::Function.new( HRESULT, [THIS_, PWSTR_OUT, ULONG, PULONG], @vtable[126], :convention=>:stdcall  ),
        :AssembleWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCWSTR, PULONG64], @vtable[127], :convention=>:stdcall  ),
        :DisassembleWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PWSTR_OUT, ULONG, PULONG, PULONG64], @vtable[128], :convention=>:stdcall  ),
        :GetProcessorTypeNamesWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PWSTR_OUT, ULONG, PULONG, PWSTR_OUT, ULONG, PULONG], @vtable[129], :convention=>:stdcall  ),
        :GetTextMacroWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PWSTR_OUT, ULONG, PULONG], @vtable[130], :convention=>:stdcall  ),
        :SetTextMacroWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PCWSTR], @vtable[131], :convention=>:stdcall  ),
        :EvaluateWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, ULONG, PDEBUG_VALUE, PULONG], @vtable[132], :convention=>:stdcall  ),
        :ExecuteWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PCWSTR, ULONG], @vtable[133], :convention=>:stdcall  ),
        :ExecuteCommandFileWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PCWSTR, ULONG], @vtable[134], :convention=>:stdcall  ),
        :GetBreakpointByIndex2 => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_BREAKPOINT2], @vtable[135], :convention=>:stdcall  ),
        :GetBreakpointById2 => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_BREAKPOINT2], @vtable[136], :convention=>:stdcall  ),
        :AddBreakpoint2 => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PDEBUG_BREAKPOINT2], @vtable[137], :convention=>:stdcall  ),
        :RemoveBreakpoint2 => FFI::Function.new( HRESULT, [THIS_, PDEBUG_BREAKPOINT2], @vtable[138], :convention=>:stdcall  ),
        :AddExtensionWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, ULONG, PULONG64], @vtable[139], :convention=>:stdcall  ),
        :GetExtensionByPathWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, PULONG64], @vtable[140], :convention=>:stdcall  ),
        :CallExtensionWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCWSTR, PCWSTR], @vtable[141], :convention=>:stdcall  ),
        :GetExtensionFunctionWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCWSTR, FARPROC], @vtable[142], :convention=>:stdcall  ),
        :GetEventFilterTextWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PWSTR_OUT, ULONG, PULONG], @vtable[143], :convention=>:stdcall  ),
        :GetEventFilterCommandWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PWSTR_OUT, ULONG, PULONG], @vtable[144], :convention=>:stdcall  ),
        :SetEventFilterCommandWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PCWSTR], @vtable[145], :convention=>:stdcall  ),
        :GetSpecificFilterArgumentWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PWSTR_OUT, ULONG, PULONG], @vtable[146], :convention=>:stdcall  ),
        :SetSpecificFilterArgumentWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PCWSTR], @vtable[147], :convention=>:stdcall  ),
        :GetExceptionFilterSecondCommandWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PWSTR_OUT, ULONG, PULONG], @vtable[148], :convention=>:stdcall  ),
        :SetExceptionFilterSecondCommandWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PCWSTR], @vtable[149], :convention=>:stdcall  ),
        :GetLastEventInformationWide => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG, PULONG, PVOID, ULONG, PULONG, PWSTR_OUT, ULONG, PULONG], @vtable[150], :convention=>:stdcall  ),
        :GetTextReplacementWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, ULONG, PWSTR_OUT, ULONG, PULONG, PWSTR_OUT, ULONG, PULONG], @vtable[151], :convention=>:stdcall  ),
        :SetTextReplacementWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, PCWSTR], @vtable[152], :convention=>:stdcall  ),
        :SetExpressionSyntaxByNameWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR], @vtable[153], :convention=>:stdcall  ),
        :GetExpressionSyntaxNamesWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PWSTR_OUT, ULONG, PULONG, PWSTR_OUT, ULONG, PULONG], @vtable[154], :convention=>:stdcall  ),
        :GetEventIndexDescriptionWide => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PWSTR, ULONG, PULONG], @vtable[155], :convention=>:stdcall  ),
        :GetLogFile2 => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG, PULONG], @vtable[156], :convention=>:stdcall  ),
        :OpenLogFile2 => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG], @vtable[157], :convention=>:stdcall  ),
        :GetLogFile2Wide => FFI::Function.new( HRESULT, [THIS_, PWSTR_OUT, ULONG, PULONG, PULONG], @vtable[158], :convention=>:stdcall  ),
        :OpenLogFile2Wide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, ULONG], @vtable[159], :convention=>:stdcall  ),
        :GetSystemVersionValues => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG, PULONG, PULONG, PULONG], @vtable[160], :convention=>:stdcall  ),
        :GetSystemVersionString => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[161], :convention=>:stdcall  ),
        :GetSystemVersionStringWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PWSTR_OUT, ULONG, PULONG], @vtable[162], :convention=>:stdcall  ),
        :GetContextStackTrace => FFI::Function.new( HRESULT, [THIS_, PVOID, ULONG, PDEBUG_STACK_FRAME, ULONG, PVOID, ULONG, ULONG, PULONG], @vtable[163], :convention=>:stdcall  ),
        :OutputContextStackTrace => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_STACK_FRAME, ULONG, PVOID, ULONG, ULONG, ULONG], @vtable[164], :convention=>:stdcall  ),
        :GetStoredEventInformation => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG, PULONG, PVOID, ULONG, PULONG, PVOID, ULONG, PULONG], @vtable[165], :convention=>:stdcall  ),
        :GetManagedStatus => FFI::Function.new( HRESULT, [THIS_, PULONG, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[166], :convention=>:stdcall  ),
        :GetManagedStatusWide => FFI::Function.new( HRESULT, [THIS_, PULONG, ULONG, PWSTR_OUT, ULONG, PULONG], @vtable[167], :convention=>:stdcall  ),
        :ResetManagedStatus => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[168], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugDataSpaces

    DEBUG_DATA_SPACE_VIRTUAL                     = 0
    DEBUG_DATA_SPACE_PHYSICAL                    = 1
    DEBUG_DATA_SPACE_CONTROL                     = 2
    DEBUG_DATA_SPACE_IO                          = 3
    DEBUG_DATA_SPACE_MSR                         = 4
    DEBUG_DATA_SPACE_BUS_DATA                    = 5
    DEBUG_DATA_SPACE_DEBUGGER_DATA               = 6
    DEBUG_DATA_SPACE_COUNT                       = 7
    DEBUG_DATA_KernBase                          = 24
    DEBUG_DATA_BreakpointWithStatusAddr          = 32
    DEBUG_DATA_SavedContextAddr                  = 40
    DEBUG_DATA_KiCallUserModeAddr                = 56
    DEBUG_DATA_KeUserCallbackDispatcherAddr      = 64
    DEBUG_DATA_PsLoadedModuleListAddr            = 72
    DEBUG_DATA_PsActiveProcessHeadAddr           = 80
    DEBUG_DATA_PspCidTableAddr                   = 88
    DEBUG_DATA_ExpSystemResourcesListAddr        = 96
    DEBUG_DATA_ExpPagedPoolDescriptorAddr        = 104
    DEBUG_DATA_ExpNumberOfPagedPoolsAddr         = 112
    DEBUG_DATA_KeTimeIncrementAddr               = 120
    DEBUG_DATA_KeBugCheckCallbackListHeadAddr    = 128
    DEBUG_DATA_KiBugcheckDataAddr                = 136
    DEBUG_DATA_IopErrorLogListHeadAddr           = 144
    DEBUG_DATA_ObpRootDirectoryObjectAddr        = 152
    DEBUG_DATA_ObpTypeObjectTypeAddr             = 160
    DEBUG_DATA_MmSystemCacheStartAddr            = 168
    DEBUG_DATA_MmSystemCacheEndAddr              = 176
    DEBUG_DATA_MmSystemCacheWsAddr               = 184
    DEBUG_DATA_MmPfnDatabaseAddr                 = 192
    DEBUG_DATA_MmSystemPtesStartAddr             = 200
    DEBUG_DATA_MmSystemPtesEndAddr               = 208
    DEBUG_DATA_MmSubsectionBaseAddr              = 216
    DEBUG_DATA_MmNumberOfPagingFilesAddr         = 224
    DEBUG_DATA_MmLowestPhysicalPageAddr          = 232
    DEBUG_DATA_MmHighestPhysicalPageAddr         = 240
    DEBUG_DATA_MmNumberOfPhysicalPagesAddr       = 248
    DEBUG_DATA_MmMaximumNonPagedPoolInBytesAddr  = 256
    DEBUG_DATA_MmNonPagedSystemStartAddr         = 264
    DEBUG_DATA_MmNonPagedPoolStartAddr           = 272
    DEBUG_DATA_MmNonPagedPoolEndAddr             = 280
    DEBUG_DATA_MmPagedPoolStartAddr              = 288
    DEBUG_DATA_MmPagedPoolEndAddr                = 296
    DEBUG_DATA_MmPagedPoolInformationAddr        = 304
    DEBUG_DATA_MmPageSize                        = 312
    DEBUG_DATA_MmSizeOfPagedPoolInBytesAddr      = 320
    DEBUG_DATA_MmTotalCommitLimitAddr            = 328
    DEBUG_DATA_MmTotalCommittedPagesAddr         = 336
    DEBUG_DATA_MmSharedCommitAddr                = 344
    DEBUG_DATA_MmDriverCommitAddr                = 352
    DEBUG_DATA_MmProcessCommitAddr               = 360
    DEBUG_DATA_MmPagedPoolCommitAddr             = 368
    DEBUG_DATA_MmExtendedCommitAddr              = 376
    DEBUG_DATA_MmZeroedPageListHeadAddr          = 384
    DEBUG_DATA_MmFreePageListHeadAddr            = 392
    DEBUG_DATA_MmStandbyPageListHeadAddr         = 400
    DEBUG_DATA_MmModifiedPageListHeadAddr        = 408
    DEBUG_DATA_MmModifiedNoWritePageListHeadAddr = 416
    DEBUG_DATA_MmAvailablePagesAddr              = 424
    DEBUG_DATA_MmResidentAvailablePagesAddr      = 432
    DEBUG_DATA_PoolTrackTableAddr                = 440
    DEBUG_DATA_NonPagedPoolDescriptorAddr        = 448
    DEBUG_DATA_MmHighestUserAddressAddr          = 456
    DEBUG_DATA_MmSystemRangeStartAddr            = 464
    DEBUG_DATA_MmUserProbeAddressAddr            = 472
    DEBUG_DATA_KdPrintCircularBufferAddr         = 480
    DEBUG_DATA_KdPrintCircularBufferEndAddr      = 488
    DEBUG_DATA_KdPrintWritePointerAddr           = 496
    DEBUG_DATA_KdPrintRolloverCountAddr          = 504
    DEBUG_DATA_MmLoadedUserImageListAddr         = 512
    DEBUG_DATA_NtBuildLabAddr                    = 520
    DEBUG_DATA_KiNormalSystemCall                = 528
    DEBUG_DATA_KiProcessorBlockAddr              = 536
    DEBUG_DATA_MmUnloadedDriversAddr             = 544
    DEBUG_DATA_MmLastUnloadedDriverAddr          = 552
    DEBUG_DATA_MmTriageActionTakenAddr           = 560
    DEBUG_DATA_MmSpecialPoolTagAddr              = 568
    DEBUG_DATA_KernelVerifierAddr                = 576
    DEBUG_DATA_MmVerifierDataAddr                = 584
    DEBUG_DATA_MmAllocatedNonPagedPoolAddr       = 592
    DEBUG_DATA_MmPeakCommitmentAddr              = 600
    DEBUG_DATA_MmTotalCommitLimitMaximumAddr     = 608
    DEBUG_DATA_CmNtCSDVersionAddr                = 616
    DEBUG_DATA_MmPhysicalMemoryBlockAddr         = 624
    DEBUG_DATA_MmSessionBase                     = 632
    DEBUG_DATA_MmSessionSize                     = 640
    DEBUG_DATA_MmSystemParentTablePage           = 648
    DEBUG_DATA_MmVirtualTranslationBase          = 656
    DEBUG_DATA_OffsetKThreadNextProcessor        = 664
    DEBUG_DATA_OffsetKThreadTeb                  = 666
    DEBUG_DATA_OffsetKThreadKernelStack          = 668
    DEBUG_DATA_OffsetKThreadInitialStack         = 670
    DEBUG_DATA_OffsetKThreadApcProcess           = 672
    DEBUG_DATA_OffsetKThreadState                = 674
    DEBUG_DATA_OffsetKThreadBStore               = 676
    DEBUG_DATA_OffsetKThreadBStoreLimit          = 678
    DEBUG_DATA_SizeEProcess                      = 680
    DEBUG_DATA_OffsetEprocessPeb                 = 682
    DEBUG_DATA_OffsetEprocessParentCID           = 684
    DEBUG_DATA_OffsetEprocessDirectoryTableBase  = 686
    DEBUG_DATA_SizePrcb                          = 688
    DEBUG_DATA_OffsetPrcbDpcRoutine              = 690
    DEBUG_DATA_OffsetPrcbCurrentThread           = 692
    DEBUG_DATA_OffsetPrcbMhz                     = 694
    DEBUG_DATA_OffsetPrcbCpuType                 = 696
    DEBUG_DATA_OffsetPrcbVendorString            = 698
    DEBUG_DATA_OffsetPrcbProcessorState          = 700
    DEBUG_DATA_OffsetPrcbNumber                  = 702
    DEBUG_DATA_SizeEThread                       = 704
    DEBUG_DATA_KdPrintCircularBufferPtrAddr      = 712
    DEBUG_DATA_KdPrintBufferSizeAddr             = 720
    DEBUG_DATA_MmBadPagesDetected                = 800
    DEBUG_DATA_EtwpDebuggerData                  = 816
    DEBUG_DATA_PaeEnabled                        = 100000
    DEBUG_DATA_SharedUserData                    = 100008
    DEBUG_DATA_ProductType                       = 100016
    DEBUG_DATA_SuiteMask                         = 100024
    DEBUG_DATA_DumpWriterStatus                  = 100032
    DEBUG_DATA_DumpFormatVersion                 = 100040
    DEBUG_DATA_DumpWriterVersion                 = 100048
    DEBUG_DATA_DumpPowerState                    = 100056
    DEBUG_DATA_DumpMmStorage                     = 100064
    DEBUG_DATA_KPCR_OFFSET                       = 0
    DEBUG_DATA_KPRCB_OFFSET                      = 1
    DEBUG_DATA_KTHREAD_OFFSET                    = 2
    DEBUG_DATA_BASE_TRANSLATION_VIRTUAL_OFFSET   = 3
    DEBUG_DATA_PROCESSOR_IDENTIFICATION          = 4
    DEBUG_DATA_PROCESSOR_SPEED                   = 5

    NUM_APIS = 23

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :ReadVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[3], :convention=>:stdcall  ),
        :WriteVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[4], :convention=>:stdcall  ),
        :SearchVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, PVOID, ULONG, ULONG, PULONG64], @vtable[5], :convention=>:stdcall  ),
        :ReadVirtualUncached => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[6], :convention=>:stdcall  ),
        :WriteVirtualUncached => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[7], :convention=>:stdcall  ),
        :ReadPointersVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PULONG64], @vtable[8], :convention=>:stdcall  ),
        :WritePointersVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PULONG64], @vtable[9], :convention=>:stdcall  ),
        :ReadPhysical => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[10], :convention=>:stdcall  ),
        :WritePhysical => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[11], :convention=>:stdcall  ),
        :ReadControl => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PVOID, ULONG, PULONG], @vtable[12], :convention=>:stdcall  ),
        :WriteControl => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PVOID, ULONG, PULONG], @vtable[13], :convention=>:stdcall  ),
        :ReadIo => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG, ULONG64, PVOID, ULONG, PULONG], @vtable[14], :convention=>:stdcall  ),
        :WriteIo => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG, ULONG64, PVOID, ULONG, PULONG], @vtable[15], :convention=>:stdcall  ),
        :ReadMsr => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG64], @vtable[16], :convention=>:stdcall  ),
        :WriteMsr => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64], @vtable[17], :convention=>:stdcall  ),
        :ReadBusData => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG, PULONG], @vtable[18], :convention=>:stdcall  ),
        :WriteBusData => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG, PULONG], @vtable[19], :convention=>:stdcall  ),
        :CheckLowMemory => FFI::Function.new( HRESULT, [THIS_], @vtable[20], :convention=>:stdcall  ),
        :ReadDebuggerData => FFI::Function.new( HRESULT, [THIS_, ULONG, PVOID, ULONG, PULONG], @vtable[21], :convention=>:stdcall  ),
        :ReadProcessorSystemData => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PVOID, ULONG, PULONG], @vtable[22], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugDataSpaces2

    DEBUG_HANDLE_DATA_TYPE_BASIC                 = 0
    DEBUG_HANDLE_DATA_TYPE_TYPE_NAME             = 1
    DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME           = 2
    DEBUG_HANDLE_DATA_TYPE_HANDLE_COUNT          = 3
    DEBUG_HANDLE_DATA_TYPE_TYPE_NAME_WIDE        = 4
    DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME_WIDE      = 5
    DEBUG_HANDLE_DATA_TYPE_MINI_THREAD_1         = 6
    DEBUG_HANDLE_DATA_TYPE_MINI_MUTANT_1         = 7
    DEBUG_HANDLE_DATA_TYPE_MINI_MUTANT_2         = 8
    DEBUG_HANDLE_DATA_TYPE_PER_HANDLE_OPERATIONS = 9
    DEBUG_HANDLE_DATA_TYPE_ALL_HANDLE_OPERATIONS = 10
    DEBUG_HANDLE_DATA_TYPE_MINI_PROCESS_1        = 11
    DEBUG_HANDLE_DATA_TYPE_MINI_PROCESS_2        = 12

    NUM_APIS = 29

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :ReadVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[3], :convention=>:stdcall  ),
        :WriteVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[4], :convention=>:stdcall  ),
        :SearchVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, PVOID, ULONG, ULONG, PULONG64], @vtable[5], :convention=>:stdcall  ),
        :ReadVirtualUncached => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[6], :convention=>:stdcall  ),
        :WriteVirtualUncached => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[7], :convention=>:stdcall  ),
        :ReadPointersVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PULONG64], @vtable[8], :convention=>:stdcall  ),
        :WritePointersVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PULONG64], @vtable[9], :convention=>:stdcall  ),
        :ReadPhysical => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[10], :convention=>:stdcall  ),
        :WritePhysical => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[11], :convention=>:stdcall  ),
        :ReadControl => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PVOID, ULONG, PULONG], @vtable[12], :convention=>:stdcall  ),
        :WriteControl => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PVOID, ULONG, PULONG], @vtable[13], :convention=>:stdcall  ),
        :ReadIo => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG, ULONG64, PVOID, ULONG, PULONG], @vtable[14], :convention=>:stdcall  ),
        :WriteIo => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG, ULONG64, PVOID, ULONG, PULONG], @vtable[15], :convention=>:stdcall  ),
        :ReadMsr => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG64], @vtable[16], :convention=>:stdcall  ),
        :WriteMsr => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64], @vtable[17], :convention=>:stdcall  ),
        :ReadBusData => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG, PULONG], @vtable[18], :convention=>:stdcall  ),
        :WriteBusData => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG, PULONG], @vtable[19], :convention=>:stdcall  ),
        :CheckLowMemory => FFI::Function.new( HRESULT, [THIS_], @vtable[20], :convention=>:stdcall  ),
        :ReadDebuggerData => FFI::Function.new( HRESULT, [THIS_, ULONG, PVOID, ULONG, PULONG], @vtable[21], :convention=>:stdcall  ),
        :ReadProcessorSystemData => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PVOID, ULONG, PULONG], @vtable[22], :convention=>:stdcall  ),
        :VirtualToPhysical => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG64], @vtable[23], :convention=>:stdcall  ),
        :GetVirtualTranslationPhysicalOffsets => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG64, ULONG, PULONG], @vtable[24], :convention=>:stdcall  ),
        :ReadHandleData => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[25], :convention=>:stdcall  ),
        :FillVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[26], :convention=>:stdcall  ),
        :FillPhysical => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[27], :convention=>:stdcall  ),
        :QueryVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, PMEMORY_BASIC_INFORMATION64], @vtable[28], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugDataSpaces3

    NUM_APIS = 34

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :ReadVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[3], :convention=>:stdcall  ),
        :WriteVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[4], :convention=>:stdcall  ),
        :SearchVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, PVOID, ULONG, ULONG, PULONG64], @vtable[5], :convention=>:stdcall  ),
        :ReadVirtualUncached => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[6], :convention=>:stdcall  ),
        :WriteVirtualUncached => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[7], :convention=>:stdcall  ),
        :ReadPointersVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PULONG64], @vtable[8], :convention=>:stdcall  ),
        :WritePointersVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PULONG64], @vtable[9], :convention=>:stdcall  ),
        :ReadPhysical => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[10], :convention=>:stdcall  ),
        :WritePhysical => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[11], :convention=>:stdcall  ),
        :ReadControl => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PVOID, ULONG, PULONG], @vtable[12], :convention=>:stdcall  ),
        :WriteControl => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PVOID, ULONG, PULONG], @vtable[13], :convention=>:stdcall  ),
        :ReadIo => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG, ULONG64, PVOID, ULONG, PULONG], @vtable[14], :convention=>:stdcall  ),
        :WriteIo => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG, ULONG64, PVOID, ULONG, PULONG], @vtable[15], :convention=>:stdcall  ),
        :ReadMsr => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG64], @vtable[16], :convention=>:stdcall  ),
        :WriteMsr => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64], @vtable[17], :convention=>:stdcall  ),
        :ReadBusData => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG, PULONG], @vtable[18], :convention=>:stdcall  ),
        :WriteBusData => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG, PULONG], @vtable[19], :convention=>:stdcall  ),
        :CheckLowMemory => FFI::Function.new( HRESULT, [THIS_], @vtable[20], :convention=>:stdcall  ),
        :ReadDebuggerData => FFI::Function.new( HRESULT, [THIS_, ULONG, PVOID, ULONG, PULONG], @vtable[21], :convention=>:stdcall  ),
        :ReadProcessorSystemData => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PVOID, ULONG, PULONG], @vtable[22], :convention=>:stdcall  ),
        :VirtualToPhysical => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG64], @vtable[23], :convention=>:stdcall  ),
        :GetVirtualTranslationPhysicalOffsets => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG64, ULONG, PULONG], @vtable[24], :convention=>:stdcall  ),
        :ReadHandleData => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[25], :convention=>:stdcall  ),
        :FillVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[26], :convention=>:stdcall  ),
        :FillPhysical => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[27], :convention=>:stdcall  ),
        :QueryVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, PMEMORY_BASIC_INFORMATION64], @vtable[28], :convention=>:stdcall  ),
        :ReadImageNtHeaders => FFI::Function.new( HRESULT, [THIS_, ULONG64, PIMAGE_NT_HEADERS64], @vtable[29], :convention=>:stdcall  ),
        :ReadTagged => FFI::Function.new( HRESULT, [THIS_, LPGUID, ULONG, PVOID, ULONG, PULONG], @vtable[30], :convention=>:stdcall  ),
        :StartEnumTagged => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[31], :convention=>:stdcall  ),
        :GetNextTagged => FFI::Function.new( HRESULT, [THIS_, ULONG64, LPGUID, PULONG], @vtable[32], :convention=>:stdcall  ),
        :EndEnumTagged => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[33], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugDataSpaces4

    DEBUG_OFFSINFO_VIRTUAL_SOURCE      = 0x00000001
    DEBUG_VSOURCE_INVALID              = 0x00000000
    DEBUG_VSOURCE_DEBUGGEE             = 0x00000001
    DEBUG_VSOURCE_MAPPED_IMAGE         = 0x00000002
    DEBUG_VSOURCE_DUMP_WITHOUT_MEMINFO = 0x00000003
    DEBUG_VSEARCH_DEFAULT              = 0x00000000
    DEBUG_VSEARCH_WRITABLE_ONLY        = 0x00000001
    DEBUG_PHYSICAL_DEFAULT             = 0x00000000
    DEBUG_PHYSICAL_CACHED              = 0x00000001
    DEBUG_PHYSICAL_UNCACHED            = 0x00000002
    DEBUG_PHYSICAL_WRITE_COMBINED      = 0x00000003

    NUM_APIS = 44

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :ReadVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[3], :convention=>:stdcall  ),
        :WriteVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[4], :convention=>:stdcall  ),
        :SearchVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, PVOID, ULONG, ULONG, PULONG64], @vtable[5], :convention=>:stdcall  ),
        :ReadVirtualUncached => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[6], :convention=>:stdcall  ),
        :WriteVirtualUncached => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[7], :convention=>:stdcall  ),
        :ReadPointersVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PULONG64], @vtable[8], :convention=>:stdcall  ),
        :WritePointersVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PULONG64], @vtable[9], :convention=>:stdcall  ),
        :ReadPhysical => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[10], :convention=>:stdcall  ),
        :WritePhysical => FFI::Function.new( HRESULT, [THIS_, ULONG64, PVOID, ULONG, PULONG], @vtable[11], :convention=>:stdcall  ),
        :ReadControl => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PVOID, ULONG, PULONG], @vtable[12], :convention=>:stdcall  ),
        :WriteControl => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PVOID, ULONG, PULONG], @vtable[13], :convention=>:stdcall  ),
        :ReadIo => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG, ULONG64, PVOID, ULONG, PULONG], @vtable[14], :convention=>:stdcall  ),
        :WriteIo => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG, ULONG64, PVOID, ULONG, PULONG], @vtable[15], :convention=>:stdcall  ),
        :ReadMsr => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG64], @vtable[16], :convention=>:stdcall  ),
        :WriteMsr => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64], @vtable[17], :convention=>:stdcall  ),
        :ReadBusData => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG, PULONG], @vtable[18], :convention=>:stdcall  ),
        :WriteBusData => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG, PULONG], @vtable[19], :convention=>:stdcall  ),
        :CheckLowMemory => FFI::Function.new( HRESULT, [THIS_], @vtable[20], :convention=>:stdcall  ),
        :ReadDebuggerData => FFI::Function.new( HRESULT, [THIS_, ULONG, PVOID, ULONG, PULONG], @vtable[21], :convention=>:stdcall  ),
        :ReadProcessorSystemData => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PVOID, ULONG, PULONG], @vtable[22], :convention=>:stdcall  ),
        :VirtualToPhysical => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG64], @vtable[23], :convention=>:stdcall  ),
        :GetVirtualTranslationPhysicalOffsets => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG64, ULONG, PULONG], @vtable[24], :convention=>:stdcall  ),
        :ReadHandleData => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[25], :convention=>:stdcall  ),
        :FillVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[26], :convention=>:stdcall  ),
        :FillPhysical => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[27], :convention=>:stdcall  ),
        :QueryVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, PMEMORY_BASIC_INFORMATION64], @vtable[28], :convention=>:stdcall  ),
        :ReadImageNtHeaders => FFI::Function.new( HRESULT, [THIS_, ULONG64, PIMAGE_NT_HEADERS64], @vtable[29], :convention=>:stdcall  ),
        :ReadTagged => FFI::Function.new( HRESULT, [THIS_, LPGUID, ULONG, PVOID, ULONG, PULONG], @vtable[30], :convention=>:stdcall  ),
        :StartEnumTagged => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[31], :convention=>:stdcall  ),
        :GetNextTagged => FFI::Function.new( HRESULT, [THIS_, ULONG64, LPGUID, PULONG], @vtable[32], :convention=>:stdcall  ),
        :EndEnumTagged => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[33], :convention=>:stdcall  ),
        :GetOffsetInformation => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG64, PVOID, ULONG, PULONG], @vtable[34], :convention=>:stdcall  ),
        :GetNextDifferentlyValidOffsetVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG64], @vtable[35], :convention=>:stdcall  ),
        :GetValidRegionVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PULONG64, PULONG], @vtable[36], :convention=>:stdcall  ),
        :SearchVirtual2 => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG, PVOID, ULONG, ULONG, PULONG64], @vtable[37], :convention=>:stdcall  ),
        :ReadMultiByteStringVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[38], :convention=>:stdcall  ),
        :ReadMultiByteStringVirtualWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, ULONG, PWSTR_OUT, ULONG, PULONG], @vtable[39], :convention=>:stdcall  ),
        :ReadUnicodeStringVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[40], :convention=>:stdcall  ),
        :ReadUnicodeStringVirtualWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PWSTR_OUT, ULONG, PULONG], @vtable[41], :convention=>:stdcall  ),
        :ReadPhysical2 => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[42], :convention=>:stdcall  ),
        :WritePhysical2 => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[43], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugEventCallbacks

    DEBUG_EVENT_BREAKPOINT                     = 0x00000001
    DEBUG_EVENT_EXCEPTION                      = 0x00000002
    DEBUG_EVENT_CREATE_THREAD                  = 0x00000004
    DEBUG_EVENT_EXIT_THREAD                    = 0x00000008
    DEBUG_EVENT_CREATE_PROCESS                 = 0x00000010
    DEBUG_EVENT_EXIT_PROCESS                   = 0x00000020
    DEBUG_EVENT_LOAD_MODULE                    = 0x00000040
    DEBUG_EVENT_UNLOAD_MODULE                  = 0x00000080
    DEBUG_EVENT_SYSTEM_ERROR                   = 0x00000100
    DEBUG_EVENT_SESSION_STATUS                 = 0x00000200
    DEBUG_EVENT_CHANGE_DEBUGGEE_STATE          = 0x00000400
    DEBUG_EVENT_CHANGE_ENGINE_STATE            = 0x00000800
    DEBUG_EVENT_CHANGE_SYMBOL_STATE            = 0x00001000
    DEBUG_SESSION_ACTIVE                       = 0x00000000
    DEBUG_SESSION_END_SESSION_ACTIVE_TERMINATE = 0x00000001
    DEBUG_SESSION_END_SESSION_ACTIVE_DETACH    = 0x00000002
    DEBUG_SESSION_END_SESSION_PASSIVE          = 0x00000003
    DEBUG_SESSION_END                          = 0x00000004
    DEBUG_SESSION_REBOOT                       = 0x00000005
    DEBUG_SESSION_HIBERNATE                    = 0x00000006
    DEBUG_SESSION_FAILURE                      = 0x00000007
    DEBUG_CDS_ALL                              = 0xffffffff
    DEBUG_CDS_REGISTERS                        = 0x00000001
    DEBUG_CDS_DATA                             = 0x00000002
    DEBUG_CES_ALL                              = 0xffffffff
    DEBUG_CES_CURRENT_THREAD                   = 0x00000001
    DEBUG_CES_EFFECTIVE_PROCESSOR              = 0x00000002
    DEBUG_CES_BREAKPOINTS                      = 0x00000004
    DEBUG_CES_CODE_LEVEL                       = 0x00000008
    DEBUG_CES_EXECUTION_STATUS                 = 0x00000010
    DEBUG_CES_ENGINE_OPTIONS                   = 0x00000020
    DEBUG_CES_LOG_FILE                         = 0x00000040
    DEBUG_CES_RADIX                            = 0x00000080
    DEBUG_CES_EVENT_FILTERS                    = 0x00000100
    DEBUG_CES_PROCESS_OPTIONS                  = 0x00000200
    DEBUG_CES_EXTENSIONS                       = 0x00000400
    DEBUG_CES_SYSTEMS                          = 0x00000800
    DEBUG_CES_ASSEMBLY_OPTIONS                 = 0x00001000
    DEBUG_CES_EXPRESSION_SYNTAX                = 0x00002000
    DEBUG_CES_TEXT_REPLACEMENTS                = 0x00004000
    DEBUG_CSS_ALL                              = 0xffffffff
    DEBUG_CSS_LOADS                            = 0x00000001
    DEBUG_CSS_UNLOADS                          = 0x00000002
    DEBUG_CSS_SCOPE                            = 0x00000004
    DEBUG_CSS_PATHS                            = 0x00000008
    DEBUG_CSS_SYMBOL_OPTIONS                   = 0x00000010
    DEBUG_CSS_TYPE_OPTIONS                     = 0x00000020

    NUM_APIS = 17

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :GetInterestMask => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[3], :convention=>:stdcall  ),
        :Breakpoint => FFI::Function.new( HRESULT, [THIS_, PDEBUG_BREAKPOINT], @vtable[4], :convention=>:stdcall  ),
        :Exception => FFI::Function.new( HRESULT, [THIS_, PEXCEPTION_RECORD64, ULONG], @vtable[5], :convention=>:stdcall  ),
        :CreateThread => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG64], @vtable[6], :convention=>:stdcall  ),
        :ExitThread => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[7], :convention=>:stdcall  ),
        :CreateProcess => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG64, ULONG, PCSTR, PCSTR, ULONG, ULONG, ULONG64, ULONG64, ULONG64], @vtable[8], :convention=>:stdcall  ),
        :ExitProcess => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[9], :convention=>:stdcall  ),
        :LoadModule => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG, PCSTR, PCSTR, ULONG, ULONG], @vtable[10], :convention=>:stdcall  ),
        :UnloadModule => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG64], @vtable[11], :convention=>:stdcall  ),
        :SystemError => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[12], :convention=>:stdcall  ),
        :SessionStatus => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[13], :convention=>:stdcall  ),
        :ChangeDebuggeeState => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64], @vtable[14], :convention=>:stdcall  ),
        :ChangeEngineState => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64], @vtable[15], :convention=>:stdcall  ),
        :ChangeSymbolState => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64], @vtable[16], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugEventCallbacksWide

    NUM_APIS = 17

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :GetInterestMask => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[3], :convention=>:stdcall  ),
        :Breakpoint => FFI::Function.new( HRESULT, [THIS_, PDEBUG_BREAKPOINT2], @vtable[4], :convention=>:stdcall  ),
        :Exception => FFI::Function.new( HRESULT, [THIS_, PEXCEPTION_RECORD64, ULONG], @vtable[5], :convention=>:stdcall  ),
        :CreateThread => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG64], @vtable[6], :convention=>:stdcall  ),
        :ExitThread => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[7], :convention=>:stdcall  ),
        :CreateProcess => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG64, ULONG, PCWSTR, PCWSTR, ULONG, ULONG, ULONG64, ULONG64, ULONG64], @vtable[8], :convention=>:stdcall  ),
        :ExitProcess => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[9], :convention=>:stdcall  ),
        :LoadModule => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG, PCWSTR, PCWSTR, ULONG, ULONG], @vtable[10], :convention=>:stdcall  ),
        :UnloadModule => FFI::Function.new( HRESULT, [THIS_, PCWSTR, ULONG64], @vtable[11], :convention=>:stdcall  ),
        :SystemError => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[12], :convention=>:stdcall  ),
        :SessionStatus => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[13], :convention=>:stdcall  ),
        :ChangeDebuggeeState => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64], @vtable[14], :convention=>:stdcall  ),
        :ChangeEngineState => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64], @vtable[15], :convention=>:stdcall  ),
        :ChangeSymbolState => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64], @vtable[16], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugInputCallbacks

    NUM_APIS = 5

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :StartInput => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[3], :convention=>:stdcall  ),
        :EndInput => FFI::Function.new( HRESULT, [THIS_], @vtable[4], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugOutputCallbacks

    NUM_APIS = 4

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :Output => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[3], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugOutputCallbacksWide

    NUM_APIS = 4

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :Output => FFI::Function.new( HRESULT, [THIS_, ULONG, PCWSTR], @vtable[3], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugOutputCallbacks2

    DEBUG_OUTCBI_EXPLICIT_FLUSH             = 0x00000001
    DEBUG_OUTCBI_TEXT                       = 0x00000002
    DEBUG_OUTCBI_DML                        = 0x00000004
    DEBUG_OUTCBI_ANY_FORMAT                 = 0x00000006
    DEBUG_OUTCB_TEXT                        = 0
    DEBUG_OUTCB_DML                         = 1
    DEBUG_OUTCB_EXPLICIT_FLUSH              = 2
    DEBUG_OUTCBF_COMBINED_EXPLICIT_FLUSH    = 0x00000001
    DEBUG_OUTCBF_DML_HAS_TAGS               = 0x00000002
    DEBUG_OUTCBF_DML_HAS_SPECIAL_CHARACTERS = 0x00000004

    NUM_APIS = 6

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :Output => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[3], :convention=>:stdcall  ),
        :GetInterestMask => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[4], :convention=>:stdcall  ),
        :Output2 => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG64, PCWSTR], @vtable[5], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugRegisters

    DEBUG_REGISTERS_DEFAULT     = 0x00000000
    DEBUG_REGISTERS_INT32       = 0x00000001
    DEBUG_REGISTERS_INT64       = 0x00000002
    DEBUG_REGISTERS_FLOAT       = 0x00000004
    DEBUG_REGISTERS_ALL         = 0x00000007
    DEBUG_REGISTER_SUB_REGISTER = 0x00000001

    NUM_APIS = 14

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :GetNumberRegisters => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[3], :convention=>:stdcall  ),
        :GetDescription => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG, PDEBUG_REGISTER_DESCRIPTION], @vtable[4], :convention=>:stdcall  ),
        :GetIndexByName => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG], @vtable[5], :convention=>:stdcall  ),
        :GetValue => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_VALUE], @vtable[6], :convention=>:stdcall  ),
        :SetValue => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_VALUE], @vtable[7], :convention=>:stdcall  ),
        :GetValues => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG, ULONG, PDEBUG_VALUE], @vtable[8], :convention=>:stdcall  ),
        :SetValues => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG, ULONG, PDEBUG_VALUE], @vtable[9], :convention=>:stdcall  ),
        :OutputRegisters => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[10], :convention=>:stdcall  ),
        :GetInstructionOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[11], :convention=>:stdcall  ),
        :GetStackOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[12], :convention=>:stdcall  ),
        :GetFrameOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[13], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugRegisters2

    DEBUG_REGSRC_DEBUGGEE = 0x00000000
    DEBUG_REGSRC_EXPLICIT = 0x00000001
    DEBUG_REGSRC_FRAME    = 0x00000002

    NUM_APIS = 29

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :GetNumberRegisters => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[3], :convention=>:stdcall  ),
        :GetDescription => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG, PDEBUG_REGISTER_DESCRIPTION], @vtable[4], :convention=>:stdcall  ),
        :GetIndexByName => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG], @vtable[5], :convention=>:stdcall  ),
        :GetValue => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_VALUE], @vtable[6], :convention=>:stdcall  ),
        :SetValue => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_VALUE], @vtable[7], :convention=>:stdcall  ),
        :GetValues => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG, ULONG, PDEBUG_VALUE], @vtable[8], :convention=>:stdcall  ),
        :SetValues => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG, ULONG, PDEBUG_VALUE], @vtable[9], :convention=>:stdcall  ),
        :OutputRegisters => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG], @vtable[10], :convention=>:stdcall  ),
        :GetInstructionOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[11], :convention=>:stdcall  ),
        :GetStackOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[12], :convention=>:stdcall  ),
        :GetFrameOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[13], :convention=>:stdcall  ),
        :GetDescriptionWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PWSTR_OUT, ULONG, PULONG, PDEBUG_REGISTER_DESCRIPTION], @vtable[14], :convention=>:stdcall  ),
        :GetIndexByNameWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, PULONG], @vtable[15], :convention=>:stdcall  ),
        :GetNumberPseudoRegisters => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[16], :convention=>:stdcall  ),
        :GetPseudoDescription => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG, PULONG64, PULONG], @vtable[17], :convention=>:stdcall  ),
        :GetPseudoDescriptionWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PWSTR_OUT, ULONG, PULONG, PULONG64, PULONG], @vtable[18], :convention=>:stdcall  ),
        :GetPseudoIndexByName => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG], @vtable[19], :convention=>:stdcall  ),
        :GetPseudoIndexByNameWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, PULONG], @vtable[20], :convention=>:stdcall  ),
        :GetPseudoValues => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG, ULONG, PDEBUG_VALUE], @vtable[21], :convention=>:stdcall  ),
        :SetPseudoValues => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG, ULONG, PDEBUG_VALUE], @vtable[22], :convention=>:stdcall  ),
        :GetValues2 => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG, ULONG, PDEBUG_VALUE], @vtable[23], :convention=>:stdcall  ),
        :SetValues2 => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG, ULONG, PDEBUG_VALUE], @vtable[24], :convention=>:stdcall  ),
        :OutputRegisters2 => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG], @vtable[25], :convention=>:stdcall  ),
        :GetInstructionOffset2 => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG64], @vtable[26], :convention=>:stdcall  ),
        :GetStackOffset2 => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG64], @vtable[27], :convention=>:stdcall  ),
        :GetFrameOffset2 => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG64], @vtable[28], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugSymbolGroup

    DEBUG_OUTPUT_SYMBOLS_DEFAULT      = 0x00000000
    DEBUG_OUTPUT_SYMBOLS_NO_NAMES     = 0x00000001
    DEBUG_OUTPUT_SYMBOLS_NO_OFFSETS   = 0x00000002
    DEBUG_OUTPUT_SYMBOLS_NO_VALUES    = 0x00000004
    DEBUG_OUTPUT_SYMBOLS_NO_TYPES     = 0x00000010
    DEBUG_OUTPUT_NAME_END             = "**NAME**"
    DEBUG_OUTPUT_OFFSET_END           = "**OFF**"
    DEBUG_OUTPUT_VALUE_END            = "**VALUE**"
    DEBUG_OUTPUT_TYPE_END             = "**TYPE**"
    # DEBUG_OUTPUT_NAME_END_WIDE        = L"**NAME**"
    # DEBUG_OUTPUT_OFFSET_END_WIDE      = L"**OFF**"
    # DEBUG_OUTPUT_VALUE_END_WIDE       = L"**VALUE**"
    # DEBUG_OUTPUT_TYPE_END_WIDE        = L"**TYPE**"
    DEBUG_SYMBOL_EXPANSION_LEVEL_MASK = 0x0000000f
    DEBUG_SYMBOL_EXPANDED             = 0x00000010
    DEBUG_SYMBOL_READ_ONLY            = 0x00000020
    DEBUG_SYMBOL_IS_ARRAY             = 0x00000040
    DEBUG_SYMBOL_IS_FLOAT             = 0x00000080
    DEBUG_SYMBOL_IS_ARGUMENT          = 0x00000100
    DEBUG_SYMBOL_IS_LOCAL             = 0x00000200

    NUM_APIS = 13

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :GetNumberSymbols => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[3], :convention=>:stdcall  ),
        :AddSymbol => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG], @vtable[4], :convention=>:stdcall  ),
        :RemoveSymbolByName => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[5], :convention=>:stdcall  ),
        :RemoveSymbolByIndex => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[6], :convention=>:stdcall  ),
        :GetSymbolName => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[7], :convention=>:stdcall  ),
        :GetSymbolParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PDEBUG_SYMBOL_PARAMETERS], @vtable[8], :convention=>:stdcall  ),
        :ExpandSymbol => FFI::Function.new( HRESULT, [THIS_, ULONG, BOOL], @vtable[9], :convention=>:stdcall  ),
        :OutputSymbols => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG, ULONG], @vtable[10], :convention=>:stdcall  ),
        :WriteSymbol => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[11], :convention=>:stdcall  ),
        :OutputAsType => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[12], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugSymbolGroup2

    DEBUG_SYMENT_IS_CODE      = 0x00000001
    DEBUG_SYMENT_IS_DATA      = 0x00000002
    DEBUG_SYMENT_IS_PARAMETER = 0x00000004
    DEBUG_SYMENT_IS_LOCAL     = 0x00000008
    DEBUG_SYMENT_IS_MANAGED   = 0x00000010
    DEBUG_SYMENT_IS_SYNTHETIC = 0x00000020

    NUM_APIS = 26

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :GetNumberSymbols => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[3], :convention=>:stdcall  ),
        :AddSymbol => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG], @vtable[4], :convention=>:stdcall  ),
        :RemoveSymbolByName => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[5], :convention=>:stdcall  ),
        :RemoveSymbolByIndex => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[6], :convention=>:stdcall  ),
        :GetSymbolName => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[7], :convention=>:stdcall  ),
        :GetSymbolParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PDEBUG_SYMBOL_PARAMETERS], @vtable[8], :convention=>:stdcall  ),
        :ExpandSymbol => FFI::Function.new( HRESULT, [THIS_, ULONG, BOOL], @vtable[9], :convention=>:stdcall  ),
        :OutputSymbols => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG, ULONG], @vtable[10], :convention=>:stdcall  ),
        :WriteSymbol => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[11], :convention=>:stdcall  ),
        :OutputAsType => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR], @vtable[12], :convention=>:stdcall  ),
        :AddSymbolWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, PULONG], @vtable[13], :convention=>:stdcall  ),
        :RemoveSymbolByNameWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR], @vtable[14], :convention=>:stdcall  ),
        :GetSymbolNameWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PWSTR_OUT, ULONG, PULONG], @vtable[15], :convention=>:stdcall  ),
        :WriteSymbolWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PCWSTR], @vtable[16], :convention=>:stdcall  ),
        :OutputAsTypeWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PCWSTR], @vtable[17], :convention=>:stdcall  ),
        :GetSymbolTypeName => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[18], :convention=>:stdcall  ),
        :GetSymbolTypeNameWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PWSTR_OUT, ULONG, PULONG], @vtable[19], :convention=>:stdcall  ),
        :GetSymbolSize => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG], @vtable[20], :convention=>:stdcall  ),
        :GetSymbolOffset => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG64], @vtable[21], :convention=>:stdcall  ),
        :GetSymbolRegister => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG], @vtable[22], :convention=>:stdcall  ),
        :GetSymbolValueText => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[23], :convention=>:stdcall  ),
        :GetSymbolValueTextWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PWSTR_OUT, ULONG, PULONG], @vtable[24], :convention=>:stdcall  ),
        :GetSymbolEntryInformation => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_SYMBOL_ENTRY], @vtable[25], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugSymbols

    DEBUG_MODULE_LOADED            = 0x00000000
    DEBUG_MODULE_UNLOADED          = 0x00000001
    DEBUG_MODULE_USER_MODE         = 0x00000002
    DEBUG_MODULE_EXE_MODULE        = 0x00000004
    DEBUG_MODULE_EXPLICIT          = 0x00000008
    DEBUG_MODULE_SECONDARY         = 0x00000010
    DEBUG_MODULE_SYNTHETIC         = 0x00000020
    DEBUG_MODULE_SYM_BAD_CHECKSUM  = 0x00010000
    DEBUG_SYMTYPE_NONE             = 0
    DEBUG_SYMTYPE_COFF             = 1
    DEBUG_SYMTYPE_CODEVIEW         = 2
    DEBUG_SYMTYPE_PDB              = 3
    DEBUG_SYMTYPE_EXPORT           = 4
    DEBUG_SYMTYPE_DEFERRED         = 5
    DEBUG_SYMTYPE_SYM              = 6
    DEBUG_SYMTYPE_DIA              = 7
    DEBUG_SCOPE_GROUP_ARGUMENTS    = 0x00000001
    DEBUG_SCOPE_GROUP_LOCALS       = 0x00000002
    DEBUG_SCOPE_GROUP_ALL          = 0x00000003
    DEBUG_OUTTYPE_DEFAULT          = 0x00000000
    DEBUG_OUTTYPE_NO_INDENT        = 0x00000001
    DEBUG_OUTTYPE_NO_OFFSET        = 0x00000002
    DEBUG_OUTTYPE_VERBOSE          = 0x00000004
    DEBUG_OUTTYPE_COMPACT_OUTPUT   = 0x00000008
    DEBUG_OUTTYPE_ADDRESS_OF_FIELD = 0x00010000
    DEBUG_OUTTYPE_ADDRESS_AT_END   = 0x00020000
    DEBUG_OUTTYPE_BLOCK_RECURSE    = 0x00200000
    DEBUG_FIND_SOURCE_DEFAULT      = 0x00000000
    DEBUG_FIND_SOURCE_FULL_PATH    = 0x00000001
    DEBUG_FIND_SOURCE_BEST_MATCH   = 0x00000002
    DEBUG_FIND_SOURCE_NO_SRCSRV    = 0x00000004
    DEBUG_FIND_SOURCE_TOKEN_LOOKUP = 0x00000008
    DEBUG_INVALID_OFFSET           = 0xffffffffffffffff
    MODULE_ORDERS_MASK             = 0xF0000000
    MODULE_ORDERS_LOADTIME         = 0x10000000
    MODULE_ORDERS_MODULENAME       = 0x20000000

    NUM_APIS = 52

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :GetSymbolOptions => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[3], :convention=>:stdcall  ),
        :AddSymbolOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[4], :convention=>:stdcall  ),
        :RemoveSymbolOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[5], :convention=>:stdcall  ),
        :SetSymbolOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[6], :convention=>:stdcall  ),
        :GetNameByOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, PSTR_OUT, ULONG, PULONG, PULONG64], @vtable[7], :convention=>:stdcall  ),
        :GetOffsetByName => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG64], @vtable[8], :convention=>:stdcall  ),
        :GetNearNameByOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, LONG, PSTR_OUT, ULONG, PULONG, PULONG64], @vtable[9], :convention=>:stdcall  ),
        :GetLineByOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG, PSTR_OUT, ULONG, PULONG, PULONG64], @vtable[10], :convention=>:stdcall  ),
        :GetOffsetByLine => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, PULONG64], @vtable[11], :convention=>:stdcall  ),
        :GetNumberModules => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG], @vtable[12], :convention=>:stdcall  ),
        :GetModuleByIndex => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG64], @vtable[13], :convention=>:stdcall  ),
        :GetModuleByModuleName => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG, PULONG, PULONG64], @vtable[14], :convention=>:stdcall  ),
        :GetModuleByOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PULONG, PULONG64], @vtable[15], :convention=>:stdcall  ),
        :GetModuleNames => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PSTR_OUT, ULONG, PULONG, PSTR_OUT, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[16], :convention=>:stdcall  ),
        :GetModuleParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG64, ULONG, PDEBUG_MODULE_PARAMETERS], @vtable[17], :convention=>:stdcall  ),
        :GetSymbolModule => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG64], @vtable[18], :convention=>:stdcall  ),
        :GetTypeName => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[19], :convention=>:stdcall  ),
        :GetTypeId => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCSTR, PULONG], @vtable[20], :convention=>:stdcall  ),
        :GetTypeSize => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PULONG], @vtable[21], :convention=>:stdcall  ),
        :GetFieldOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PCSTR, PULONG], @vtable[22], :convention=>:stdcall  ),
        :GetSymbolTypeId => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG, PULONG64], @vtable[23], :convention=>:stdcall  ),
        :GetOffsetTypeId => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG, PULONG64], @vtable[24], :convention=>:stdcall  ),
        :ReadTypedDataVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[25], :convention=>:stdcall  ),
        :WriteTypedDataVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[26], :convention=>:stdcall  ),
        :OutputTypedDataVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, ULONG64, ULONG, ULONG], @vtable[27], :convention=>:stdcall  ),
        :ReadTypedDataPhysical => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[28], :convention=>:stdcall  ),
        :WriteTypedDataPhysical => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[29], :convention=>:stdcall  ),
        :OutputTypedDataPhysical => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, ULONG64, ULONG, ULONG], @vtable[30], :convention=>:stdcall  ),
        :GetScope => FFI::Function.new( HRESULT, [THIS_, PULONG64, PDEBUG_STACK_FRAME, PVOID, ULONG], @vtable[31], :convention=>:stdcall  ),
        :SetScope => FFI::Function.new( HRESULT, [THIS_, ULONG64, PDEBUG_STACK_FRAME, PVOID, ULONG], @vtable[32], :convention=>:stdcall  ),
        :ResetScope => FFI::Function.new( HRESULT, [THIS_], @vtable[33], :convention=>:stdcall  ),
        :GetScopeSymbolGroup => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_SYMBOL_GROUP, PDEBUG_SYMBOL_GROUP], @vtable[34], :convention=>:stdcall  ),
        :CreateSymbolGroup => FFI::Function.new( HRESULT, [THIS_, PDEBUG_SYMBOL_GROUP], @vtable[35], :convention=>:stdcall  ),
        :StartSymbolMatch => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG64], @vtable[36], :convention=>:stdcall  ),
        :GetNextSymbolMatch => FFI::Function.new( HRESULT, [THIS_, ULONG64, PSTR_OUT, ULONG, PULONG, PULONG64], @vtable[37], :convention=>:stdcall  ),
        :EndSymbolMatch => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[38], :convention=>:stdcall  ),
        :Reload => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[39], :convention=>:stdcall  ),
        :GetSymbolPath => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[40], :convention=>:stdcall  ),
        :SetSymbolPath => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[41], :convention=>:stdcall  ),
        :AppendSymbolPath => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[42], :convention=>:stdcall  ),
        :GetImagePath => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[43], :convention=>:stdcall  ),
        :SetImagePath => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[44], :convention=>:stdcall  ),
        :AppendImagePath => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[45], :convention=>:stdcall  ),
        :GetSourcePath => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[46], :convention=>:stdcall  ),
        :GetSourcePathElement => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[47], :convention=>:stdcall  ),
        :SetSourcePath => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[48], :convention=>:stdcall  ),
        :AppendSourcePath => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[49], :convention=>:stdcall  ),
        :FindSourceFile => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[50], :convention=>:stdcall  ),
        :GetSourceFileLineOffsets => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG64, ULONG, PULONG], @vtable[51], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugSymbols2

    DEBUG_MODNAME_IMAGE               = 0x00000000
    DEBUG_MODNAME_MODULE              = 0x00000001
    DEBUG_MODNAME_LOADED_IMAGE        = 0x00000002
    DEBUG_MODNAME_SYMBOL_FILE         = 0x00000003
    DEBUG_MODNAME_MAPPED_IMAGE        = 0x00000004
    DEBUG_TYPEOPTS_UNICODE_DISPLAY    = 0x00000001
    DEBUG_TYPEOPTS_LONGSTATUS_DISPLAY = 0x00000002
    DEBUG_TYPEOPTS_FORCERADIX_OUTPUT  = 0x00000004
    DEBUG_TYPEOPTS_MATCH_MAXSIZE      = 0x00000008

    NUM_APIS = 60

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :GetSymbolOptions => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[3], :convention=>:stdcall  ),
        :AddSymbolOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[4], :convention=>:stdcall  ),
        :RemoveSymbolOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[5], :convention=>:stdcall  ),
        :SetSymbolOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[6], :convention=>:stdcall  ),
        :GetNameByOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, PSTR_OUT, ULONG, PULONG, PULONG64], @vtable[7], :convention=>:stdcall  ),
        :GetOffsetByName => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG64], @vtable[8], :convention=>:stdcall  ),
        :GetNearNameByOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, LONG, PSTR_OUT, ULONG, PULONG, PULONG64], @vtable[9], :convention=>:stdcall  ),
        :GetLineByOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG, PSTR_OUT, ULONG, PULONG, PULONG64], @vtable[10], :convention=>:stdcall  ),
        :GetOffsetByLine => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, PULONG64], @vtable[11], :convention=>:stdcall  ),
        :GetNumberModules => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG], @vtable[12], :convention=>:stdcall  ),
        :GetModuleByIndex => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG64], @vtable[13], :convention=>:stdcall  ),
        :GetModuleByModuleName => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG, PULONG, PULONG64], @vtable[14], :convention=>:stdcall  ),
        :GetModuleByOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PULONG, PULONG64], @vtable[15], :convention=>:stdcall  ),
        :GetModuleNames => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PSTR_OUT, ULONG, PULONG, PSTR_OUT, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[16], :convention=>:stdcall  ),
        :GetModuleParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG64, ULONG, PDEBUG_MODULE_PARAMETERS], @vtable[17], :convention=>:stdcall  ),
        :GetSymbolModule => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG64], @vtable[18], :convention=>:stdcall  ),
        :GetTypeName => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[19], :convention=>:stdcall  ),
        :GetTypeId => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCSTR, PULONG], @vtable[20], :convention=>:stdcall  ),
        :GetTypeSize => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PULONG], @vtable[21], :convention=>:stdcall  ),
        :GetFieldOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PCSTR, PULONG], @vtable[22], :convention=>:stdcall  ),
        :GetSymbolTypeId => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG, PULONG64], @vtable[23], :convention=>:stdcall  ),
        :GetOffsetTypeId => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG, PULONG64], @vtable[24], :convention=>:stdcall  ),
        :ReadTypedDataVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[25], :convention=>:stdcall  ),
        :WriteTypedDataVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[26], :convention=>:stdcall  ),
        :OutputTypedDataVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, ULONG64, ULONG, ULONG], @vtable[27], :convention=>:stdcall  ),
        :ReadTypedDataPhysical => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[28], :convention=>:stdcall  ),
        :WriteTypedDataPhysical => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[29], :convention=>:stdcall  ),
        :OutputTypedDataPhysical => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, ULONG64, ULONG, ULONG], @vtable[30], :convention=>:stdcall  ),
        :GetScope => FFI::Function.new( HRESULT, [THIS_, PULONG64, PDEBUG_STACK_FRAME, PVOID, ULONG], @vtable[31], :convention=>:stdcall  ),
        :SetScope => FFI::Function.new( HRESULT, [THIS_, ULONG64, PDEBUG_STACK_FRAME, PVOID, ULONG], @vtable[32], :convention=>:stdcall  ),
        :ResetScope => FFI::Function.new( HRESULT, [THIS_], @vtable[33], :convention=>:stdcall  ),
        :GetScopeSymbolGroup => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_SYMBOL_GROUP, PDEBUG_SYMBOL_GROUP], @vtable[34], :convention=>:stdcall  ),
        :CreateSymbolGroup => FFI::Function.new( HRESULT, [THIS_, PDEBUG_SYMBOL_GROUP], @vtable[35], :convention=>:stdcall  ),
        :StartSymbolMatch => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG64], @vtable[36], :convention=>:stdcall  ),
        :GetNextSymbolMatch => FFI::Function.new( HRESULT, [THIS_, ULONG64, PSTR_OUT, ULONG, PULONG, PULONG64], @vtable[37], :convention=>:stdcall  ),
        :EndSymbolMatch => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[38], :convention=>:stdcall  ),
        :Reload => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[39], :convention=>:stdcall  ),
        :GetSymbolPath => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[40], :convention=>:stdcall  ),
        :SetSymbolPath => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[41], :convention=>:stdcall  ),
        :AppendSymbolPath => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[42], :convention=>:stdcall  ),
        :GetImagePath => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[43], :convention=>:stdcall  ),
        :SetImagePath => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[44], :convention=>:stdcall  ),
        :AppendImagePath => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[45], :convention=>:stdcall  ),
        :GetSourcePath => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[46], :convention=>:stdcall  ),
        :GetSourcePathElement => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[47], :convention=>:stdcall  ),
        :SetSourcePath => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[48], :convention=>:stdcall  ),
        :AppendSourcePath => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[49], :convention=>:stdcall  ),
        :FindSourceFile => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[50], :convention=>:stdcall  ),
        :GetSourceFileLineOffsets => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG64, ULONG, PULONG], @vtable[51], :convention=>:stdcall  ),
        :GetModuleVersionInformation => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PCSTR, PVOID, ULONG, PULONG], @vtable[52], :convention=>:stdcall  ),
        :GetModuleNameString => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG64, PSTR_OUT, ULONG, PULONG], @vtable[53], :convention=>:stdcall  ),
        :GetConstantName => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, ULONG64, PSTR_OUT, ULONG, PULONG], @vtable[54], :convention=>:stdcall  ),
        :GetFieldName => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[55], :convention=>:stdcall  ),
        :GetTypeOptions => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[56], :convention=>:stdcall  ),
        :AddTypeOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[57], :convention=>:stdcall  ),
        :RemoveTypeOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[58], :convention=>:stdcall  ),
        :SetTypeOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[59], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugSymbols3

    DEBUG_GETMOD_DEFAULT             = 0x00000000
    DEBUG_GETMOD_NO_LOADED_MODULES   = 0x00000001
    DEBUG_GETMOD_NO_UNLOADED_MODULES = 0x00000002
    DEBUG_ADDSYNTHMOD_DEFAULT        = 0x00000000
    DEBUG_ADDSYNTHSYM_DEFAULT        = 0x00000000
    DEBUG_OUTSYM_DEFAULT             = 0x00000000
    DEBUG_OUTSYM_FORCE_OFFSET        = 0x00000001
    DEBUG_OUTSYM_SOURCE_LINE         = 0x00000002
    DEBUG_OUTSYM_ALLOW_DISPLACEMENT  = 0x00000004
    DEBUG_GETFNENT_DEFAULT           = 0x00000000
    DEBUG_GETFNENT_RAW_ENTRY_ONLY    = 0x00000001
    DEBUG_SOURCE_IS_STATEMENT        = 0x00000001
    DEBUG_GSEL_DEFAULT               = 0x00000000
    DEBUG_GSEL_NO_SYMBOL_LOADS       = 0x00000001
    DEBUG_GSEL_ALLOW_LOWER           = 0x00000002
    DEBUG_GSEL_ALLOW_HIGHER          = 0x00000004
    DEBUG_GSEL_NEAREST_ONLY          = 0x00000008

    NUM_APIS = 126

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :GetSymbolOptions => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[3], :convention=>:stdcall  ),
        :AddSymbolOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[4], :convention=>:stdcall  ),
        :RemoveSymbolOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[5], :convention=>:stdcall  ),
        :SetSymbolOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[6], :convention=>:stdcall  ),
        :GetNameByOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, PSTR_OUT, ULONG, PULONG, PULONG64], @vtable[7], :convention=>:stdcall  ),
        :GetOffsetByName => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG64], @vtable[8], :convention=>:stdcall  ),
        :GetNearNameByOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, LONG, PSTR_OUT, ULONG, PULONG, PULONG64], @vtable[9], :convention=>:stdcall  ),
        :GetLineByOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG, PSTR_OUT, ULONG, PULONG, PULONG64], @vtable[10], :convention=>:stdcall  ),
        :GetOffsetByLine => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, PULONG64], @vtable[11], :convention=>:stdcall  ),
        :GetNumberModules => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG], @vtable[12], :convention=>:stdcall  ),
        :GetModuleByIndex => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG64], @vtable[13], :convention=>:stdcall  ),
        :GetModuleByModuleName => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG, PULONG, PULONG64], @vtable[14], :convention=>:stdcall  ),
        :GetModuleByOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PULONG, PULONG64], @vtable[15], :convention=>:stdcall  ),
        :GetModuleNames => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PSTR_OUT, ULONG, PULONG, PSTR_OUT, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[16], :convention=>:stdcall  ),
        :GetModuleParameters => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG64, ULONG, PDEBUG_MODULE_PARAMETERS], @vtable[17], :convention=>:stdcall  ),
        :GetSymbolModule => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG64], @vtable[18], :convention=>:stdcall  ),
        :GetTypeName => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[19], :convention=>:stdcall  ),
        :GetTypeId => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCSTR, PULONG], @vtable[20], :convention=>:stdcall  ),
        :GetTypeSize => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PULONG], @vtable[21], :convention=>:stdcall  ),
        :GetFieldOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PCSTR, PULONG], @vtable[22], :convention=>:stdcall  ),
        :GetSymbolTypeId => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG, PULONG64], @vtable[23], :convention=>:stdcall  ),
        :GetOffsetTypeId => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG, PULONG64], @vtable[24], :convention=>:stdcall  ),
        :ReadTypedDataVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[25], :convention=>:stdcall  ),
        :WriteTypedDataVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[26], :convention=>:stdcall  ),
        :OutputTypedDataVirtual => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, ULONG64, ULONG, ULONG], @vtable[27], :convention=>:stdcall  ),
        :ReadTypedDataPhysical => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[28], :convention=>:stdcall  ),
        :WriteTypedDataPhysical => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[29], :convention=>:stdcall  ),
        :OutputTypedDataPhysical => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, ULONG64, ULONG, ULONG], @vtable[30], :convention=>:stdcall  ),
        :GetScope => FFI::Function.new( HRESULT, [THIS_, PULONG64, PDEBUG_STACK_FRAME, PVOID, ULONG], @vtable[31], :convention=>:stdcall  ),
        :SetScope => FFI::Function.new( HRESULT, [THIS_, ULONG64, PDEBUG_STACK_FRAME, PVOID, ULONG], @vtable[32], :convention=>:stdcall  ),
        :ResetScope => FFI::Function.new( HRESULT, [THIS_], @vtable[33], :convention=>:stdcall  ),
        :GetScopeSymbolGroup => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_SYMBOL_GROUP, PDEBUG_SYMBOL_GROUP], @vtable[34], :convention=>:stdcall  ),
        :CreateSymbolGroup => FFI::Function.new( HRESULT, [THIS_, PDEBUG_SYMBOL_GROUP], @vtable[35], :convention=>:stdcall  ),
        :StartSymbolMatch => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG64], @vtable[36], :convention=>:stdcall  ),
        :GetNextSymbolMatch => FFI::Function.new( HRESULT, [THIS_, ULONG64, PSTR_OUT, ULONG, PULONG, PULONG64], @vtable[37], :convention=>:stdcall  ),
        :EndSymbolMatch => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[38], :convention=>:stdcall  ),
        :Reload => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[39], :convention=>:stdcall  ),
        :GetSymbolPath => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[40], :convention=>:stdcall  ),
        :SetSymbolPath => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[41], :convention=>:stdcall  ),
        :AppendSymbolPath => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[42], :convention=>:stdcall  ),
        :GetImagePath => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[43], :convention=>:stdcall  ),
        :SetImagePath => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[44], :convention=>:stdcall  ),
        :AppendImagePath => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[45], :convention=>:stdcall  ),
        :GetSourcePath => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[46], :convention=>:stdcall  ),
        :GetSourcePathElement => FFI::Function.new( HRESULT, [THIS_, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[47], :convention=>:stdcall  ),
        :SetSourcePath => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[48], :convention=>:stdcall  ),
        :AppendSourcePath => FFI::Function.new( HRESULT, [THIS_, PCSTR], @vtable[49], :convention=>:stdcall  ),
        :FindSourceFile => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ULONG, PULONG, PSTR_OUT, ULONG, PULONG], @vtable[50], :convention=>:stdcall  ),
        :GetSourceFileLineOffsets => FFI::Function.new( HRESULT, [THIS_, PCSTR, PULONG64, ULONG, PULONG], @vtable[51], :convention=>:stdcall  ),
        :GetModuleVersionInformation => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PCSTR, PVOID, ULONG, PULONG], @vtable[52], :convention=>:stdcall  ),
        :GetModuleNameString => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG64, PSTR_OUT, ULONG, PULONG], @vtable[53], :convention=>:stdcall  ),
        :GetConstantName => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, ULONG64, PSTR_OUT, ULONG, PULONG], @vtable[54], :convention=>:stdcall  ),
        :GetFieldName => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[55], :convention=>:stdcall  ),
        :GetTypeOptions => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[56], :convention=>:stdcall  ),
        :AddTypeOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[57], :convention=>:stdcall  ),
        :RemoveTypeOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[58], :convention=>:stdcall  ),
        :SetTypeOptions => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[59], :convention=>:stdcall  ),
        :GetNameByOffsetWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, PWSTR_OUT, ULONG, PULONG, PULONG64], @vtable[60], :convention=>:stdcall  ),
        :GetOffsetByNameWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, PULONG64], @vtable[61], :convention=>:stdcall  ),
        :GetNearNameByOffsetWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, LONG, PWSTR_OUT, ULONG, PULONG, PULONG64], @vtable[62], :convention=>:stdcall  ),
        :GetLineByOffsetWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG, PWSTR_OUT, ULONG, PULONG, PULONG64], @vtable[63], :convention=>:stdcall  ),
        :GetOffsetByLineWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PCWSTR, PULONG64], @vtable[64], :convention=>:stdcall  ),
        :GetModuleByModuleNameWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, ULONG, PULONG, PULONG64], @vtable[65], :convention=>:stdcall  ),
        :GetSymbolModuleWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, PULONG64], @vtable[66], :convention=>:stdcall  ),
        :GetTypeNameWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PWSTR_OUT, ULONG, PULONG], @vtable[67], :convention=>:stdcall  ),
        :GetTypeIdWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, PCWSTR, PULONG], @vtable[68], :convention=>:stdcall  ),
        :GetFieldOffsetWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PCWSTR, PULONG], @vtable[69], :convention=>:stdcall  ),
        :GetSymbolTypeIdWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, PULONG, PULONG64], @vtable[70], :convention=>:stdcall  ),
        :GetScopeSymbolGroup2 => FFI::Function.new( HRESULT, [THIS_, ULONG, PDEBUG_SYMBOL_GROUP2, PDEBUG_SYMBOL_GROUP2], @vtable[71], :convention=>:stdcall  ),
        :CreateSymbolGroup2 => FFI::Function.new( HRESULT, [THIS_, PDEBUG_SYMBOL_GROUP2], @vtable[72], :convention=>:stdcall  ),
        :StartSymbolMatchWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, PULONG64], @vtable[73], :convention=>:stdcall  ),
        :GetNextSymbolMatchWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, PWSTR_OUT, ULONG, PULONG, PULONG64], @vtable[74], :convention=>:stdcall  ),
        :ReloadWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR], @vtable[75], :convention=>:stdcall  ),
        :GetSymbolPathWide => FFI::Function.new( HRESULT, [THIS_, PWSTR_OUT, ULONG, PULONG], @vtable[76], :convention=>:stdcall  ),
        :SetSymbolPathWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR], @vtable[77], :convention=>:stdcall  ),
        :AppendSymbolPathWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR], @vtable[78], :convention=>:stdcall  ),
        :GetImagePathWide => FFI::Function.new( HRESULT, [THIS_, PWSTR_OUT, ULONG, PULONG], @vtable[79], :convention=>:stdcall  ),
        :SetImagePathWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR], @vtable[80], :convention=>:stdcall  ),
        :AppendImagePathWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR], @vtable[81], :convention=>:stdcall  ),
        :GetSourcePathWide => FFI::Function.new( HRESULT, [THIS_, PWSTR_OUT, ULONG, PULONG], @vtable[82], :convention=>:stdcall  ),
        :GetSourcePathElementWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PWSTR_OUT, ULONG, PULONG], @vtable[83], :convention=>:stdcall  ),
        :SetSourcePathWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR], @vtable[84], :convention=>:stdcall  ),
        :AppendSourcePathWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR], @vtable[85], :convention=>:stdcall  ),
        :FindSourceFileWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PCWSTR, ULONG, PULONG, PWSTR_OUT, ULONG, PULONG], @vtable[86], :convention=>:stdcall  ),
        :GetSourceFileLineOffsetsWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, PULONG64, ULONG, PULONG], @vtable[87], :convention=>:stdcall  ),
        :GetModuleVersionInformationWide => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64, PCWSTR, PVOID, ULONG, PULONG], @vtable[88], :convention=>:stdcall  ),
        :GetModuleNameStringWide => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG64, PWSTR_OUT, ULONG, PULONG], @vtable[89], :convention=>:stdcall  ),
        :GetConstantNameWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, ULONG64, PWSTR_OUT, ULONG, PULONG], @vtable[90], :convention=>:stdcall  ),
        :GetFieldNameWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, ULONG, PWSTR_OUT, ULONG, PULONG], @vtable[91], :convention=>:stdcall  ),
        :IsManagedModule => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64], @vtable[92], :convention=>:stdcall  ),
        :GetModuleByModuleName2 => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG, ULONG, PULONG, PULONG64], @vtable[93], :convention=>:stdcall  ),
        :GetModuleByModuleName2Wide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, ULONG, ULONG, PULONG, PULONG64], @vtable[94], :convention=>:stdcall  ),
        :GetModuleByOffset2 => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, ULONG, PULONG, PULONG64], @vtable[95], :convention=>:stdcall  ),
        :AddSyntheticModule => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PCSTR, PCSTR, ULONG], @vtable[96], :convention=>:stdcall  ),
        :AddSyntheticModuleWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PCWSTR, PCWSTR, ULONG], @vtable[97], :convention=>:stdcall  ),
        :RemoveSyntheticModule => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[98], :convention=>:stdcall  ),
        :GetCurrentScopeFrameIndex => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[99], :convention=>:stdcall  ),
        :SetScopeFrameByIndex => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[100], :convention=>:stdcall  ),
        :SetScopeFromJitDebugInfo => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG64], @vtable[101], :convention=>:stdcall  ),
        :SetScopeFromStoredEvent => FFI::Function.new( HRESULT, [THIS_], @vtable[102], :convention=>:stdcall  ),
        :OutputSymbolByOffset => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, ULONG64], @vtable[103], :convention=>:stdcall  ),
        :GetFunctionEntryByOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PVOID, ULONG, PULONG], @vtable[104], :convention=>:stdcall  ),
        :GetFieldTypeAndOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PCSTR, PULONG, PULONG], @vtable[105], :convention=>:stdcall  ),
        :GetFieldTypeAndOffsetWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PCWSTR, PULONG, PULONG], @vtable[106], :convention=>:stdcall  ),
        :AddSyntheticSymbol => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PCSTR, ULONG, PDEBUG_MODULE_AND_ID], @vtable[107], :convention=>:stdcall  ),
        :AddSyntheticSymbolWide => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PCWSTR, ULONG, PDEBUG_MODULE_AND_ID], @vtable[108], :convention=>:stdcall  ),
        :RemoveSyntheticSymbol => FFI::Function.new( HRESULT, [THIS_, PDEBUG_MODULE_AND_ID], @vtable[109], :convention=>:stdcall  ),
        :GetSymbolEntriesByOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PDEBUG_MODULE_AND_ID, PULONG64, ULONG, PULONG], @vtable[110], :convention=>:stdcall  ),
        :GetSymbolEntriesByName => FFI::Function.new( HRESULT, [THIS_, PCSTR, ULONG, PDEBUG_MODULE_AND_ID, ULONG, PULONG], @vtable[111], :convention=>:stdcall  ),
        :GetSymbolEntriesByNameWide => FFI::Function.new( HRESULT, [THIS_, PCWSTR, ULONG, PDEBUG_MODULE_AND_ID, ULONG, PULONG], @vtable[112], :convention=>:stdcall  ),
        :GetSymbolEntryByToken => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PDEBUG_MODULE_AND_ID], @vtable[113], :convention=>:stdcall  ),
        :GetSymbolEntryInformation => FFI::Function.new( HRESULT, [THIS_, PDEBUG_MODULE_AND_ID, PDEBUG_SYMBOL_ENTRY], @vtable[114], :convention=>:stdcall  ),
        :GetSymbolEntryString => FFI::Function.new( HRESULT, [THIS_, PDEBUG_MODULE_AND_ID, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[115], :convention=>:stdcall  ),
        :GetSymbolEntryStringWide => FFI::Function.new( HRESULT, [THIS_, PDEBUG_MODULE_AND_ID, ULONG, PWSTR_OUT, ULONG, PULONG], @vtable[116], :convention=>:stdcall  ),
        :GetSymbolEntryOffsetRegions => FFI::Function.new( HRESULT, [THIS_, PDEBUG_MODULE_AND_ID, ULONG, PDEBUG_OFFSET_REGION, ULONG, PULONG], @vtable[117], :convention=>:stdcall  ),
        :GetSymbolEntryBySymbolEntry => FFI::Function.new( HRESULT, [THIS_, PDEBUG_MODULE_AND_ID, ULONG, PDEBUG_MODULE_AND_ID], @vtable[118], :convention=>:stdcall  ),
        :GetSourceEntriesByOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, ULONG, PDEBUG_SYMBOL_SOURCE_ENTRY, ULONG, PULONG], @vtable[119], :convention=>:stdcall  ),
        :GetSourceEntriesByLine => FFI::Function.new( HRESULT, [THIS_, ULONG, PCSTR, ULONG, PDEBUG_SYMBOL_SOURCE_ENTRY, ULONG, PULONG], @vtable[120], :convention=>:stdcall  ),
        :GetSourceEntriesByLineWide => FFI::Function.new( HRESULT, [THIS_, ULONG, PCWSTR, ULONG, PDEBUG_SYMBOL_SOURCE_ENTRY, ULONG, PULONG], @vtable[121], :convention=>:stdcall  ),
        :GetSourceEntryString => FFI::Function.new( HRESULT, [THIS_, PDEBUG_SYMBOL_SOURCE_ENTRY, ULONG, PSTR_OUT, ULONG, PULONG], @vtable[122], :convention=>:stdcall  ),
        :GetSourceEntryStringWide => FFI::Function.new( HRESULT, [THIS_, PDEBUG_SYMBOL_SOURCE_ENTRY, ULONG, PWSTR_OUT, ULONG, PULONG], @vtable[123], :convention=>:stdcall  ),
        :GetSourceEntryOffsetRegions => FFI::Function.new( HRESULT, [THIS_, PDEBUG_SYMBOL_SOURCE_ENTRY, ULONG, PDEBUG_OFFSET_REGION, ULONG, PULONG], @vtable[124], :convention=>:stdcall  ),
        :GetSourceEntryBySourceEntry => FFI::Function.new( HRESULT, [THIS_, PDEBUG_SYMBOL_SOURCE_ENTRY, ULONG, PDEBUG_SYMBOL_SOURCE_ENTRY], @vtable[125], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugSystemObjects

    NUM_APIS = 32

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :GetEventThread => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[3], :convention=>:stdcall  ),
        :GetEventProcess => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[4], :convention=>:stdcall  ),
        :GetCurrentThreadId => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[5], :convention=>:stdcall  ),
        :SetCurrentThreadId => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[6], :convention=>:stdcall  ),
        :GetCurrentProcessId => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[7], :convention=>:stdcall  ),
        :SetCurrentProcessId => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[8], :convention=>:stdcall  ),
        :GetNumberThreads => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[9], :convention=>:stdcall  ),
        :GetTotalNumberThreads => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG], @vtable[10], :convention=>:stdcall  ),
        :GetThreadIdsByIndex => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG, PULONG], @vtable[11], :convention=>:stdcall  ),
        :GetThreadIdByProcessor => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG], @vtable[12], :convention=>:stdcall  ),
        :GetCurrentThreadDataOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[13], :convention=>:stdcall  ),
        :GetThreadIdByDataOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[14], :convention=>:stdcall  ),
        :GetCurrentThreadTeb => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[15], :convention=>:stdcall  ),
        :GetThreadIdByTeb => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[16], :convention=>:stdcall  ),
        :GetCurrentThreadSystemId => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[17], :convention=>:stdcall  ),
        :GetThreadIdBySystemId => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG], @vtable[18], :convention=>:stdcall  ),
        :GetCurrentThreadHandle => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[19], :convention=>:stdcall  ),
        :GetThreadIdByHandle => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[20], :convention=>:stdcall  ),
        :GetNumberProcesses => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[21], :convention=>:stdcall  ),
        :GetProcessIdsByIndex => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG, PULONG], @vtable[22], :convention=>:stdcall  ),
        :GetCurrentProcessDataOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[23], :convention=>:stdcall  ),
        :GetProcessIdByDataOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[24], :convention=>:stdcall  ),
        :GetCurrentProcessPeb => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[25], :convention=>:stdcall  ),
        :GetProcessIdByPeb => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[26], :convention=>:stdcall  ),
        :GetCurrentProcessSystemId => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[27], :convention=>:stdcall  ),
        :GetProcessIdBySystemId => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG], @vtable[28], :convention=>:stdcall  ),
        :GetCurrentProcessHandle => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[29], :convention=>:stdcall  ),
        :GetProcessIdByHandle => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[30], :convention=>:stdcall  ),
        :GetCurrentProcessExecutableName => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[31], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugSystemObjects2

    NUM_APIS = 37

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :GetEventThread => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[3], :convention=>:stdcall  ),
        :GetEventProcess => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[4], :convention=>:stdcall  ),
        :GetCurrentThreadId => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[5], :convention=>:stdcall  ),
        :SetCurrentThreadId => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[6], :convention=>:stdcall  ),
        :GetCurrentProcessId => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[7], :convention=>:stdcall  ),
        :SetCurrentProcessId => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[8], :convention=>:stdcall  ),
        :GetNumberThreads => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[9], :convention=>:stdcall  ),
        :GetTotalNumberThreads => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG], @vtable[10], :convention=>:stdcall  ),
        :GetThreadIdsByIndex => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG, PULONG], @vtable[11], :convention=>:stdcall  ),
        :GetThreadIdByProcessor => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG], @vtable[12], :convention=>:stdcall  ),
        :GetCurrentThreadDataOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[13], :convention=>:stdcall  ),
        :GetThreadIdByDataOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[14], :convention=>:stdcall  ),
        :GetCurrentThreadTeb => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[15], :convention=>:stdcall  ),
        :GetThreadIdByTeb => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[16], :convention=>:stdcall  ),
        :GetCurrentThreadSystemId => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[17], :convention=>:stdcall  ),
        :GetThreadIdBySystemId => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG], @vtable[18], :convention=>:stdcall  ),
        :GetCurrentThreadHandle => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[19], :convention=>:stdcall  ),
        :GetThreadIdByHandle => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[20], :convention=>:stdcall  ),
        :GetNumberProcesses => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[21], :convention=>:stdcall  ),
        :GetProcessIdsByIndex => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG, PULONG], @vtable[22], :convention=>:stdcall  ),
        :GetCurrentProcessDataOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[23], :convention=>:stdcall  ),
        :GetProcessIdByDataOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[24], :convention=>:stdcall  ),
        :GetCurrentProcessPeb => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[25], :convention=>:stdcall  ),
        :GetProcessIdByPeb => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[26], :convention=>:stdcall  ),
        :GetCurrentProcessSystemId => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[27], :convention=>:stdcall  ),
        :GetProcessIdBySystemId => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG], @vtable[28], :convention=>:stdcall  ),
        :GetCurrentProcessHandle => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[29], :convention=>:stdcall  ),
        :GetProcessIdByHandle => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[30], :convention=>:stdcall  ),
        :GetCurrentProcessExecutableName => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[31], :convention=>:stdcall  ),
        :GetCurrentProcessUpTime => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[32], :convention=>:stdcall  ),
        :GetImplicitThreadDataOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[33], :convention=>:stdcall  ),
        :SetImplicitThreadDataOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[34], :convention=>:stdcall  ),
        :GetImplicitProcessDataOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[35], :convention=>:stdcall  ),
        :SetImplicitProcessDataOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[36], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugSystemObjects3

    NUM_APIS = 46

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :GetEventThread => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[3], :convention=>:stdcall  ),
        :GetEventProcess => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[4], :convention=>:stdcall  ),
        :GetCurrentThreadId => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[5], :convention=>:stdcall  ),
        :SetCurrentThreadId => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[6], :convention=>:stdcall  ),
        :GetCurrentProcessId => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[7], :convention=>:stdcall  ),
        :SetCurrentProcessId => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[8], :convention=>:stdcall  ),
        :GetNumberThreads => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[9], :convention=>:stdcall  ),
        :GetTotalNumberThreads => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG], @vtable[10], :convention=>:stdcall  ),
        :GetThreadIdsByIndex => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG, PULONG], @vtable[11], :convention=>:stdcall  ),
        :GetThreadIdByProcessor => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG], @vtable[12], :convention=>:stdcall  ),
        :GetCurrentThreadDataOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[13], :convention=>:stdcall  ),
        :GetThreadIdByDataOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[14], :convention=>:stdcall  ),
        :GetCurrentThreadTeb => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[15], :convention=>:stdcall  ),
        :GetThreadIdByTeb => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[16], :convention=>:stdcall  ),
        :GetCurrentThreadSystemId => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[17], :convention=>:stdcall  ),
        :GetThreadIdBySystemId => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG], @vtable[18], :convention=>:stdcall  ),
        :GetCurrentThreadHandle => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[19], :convention=>:stdcall  ),
        :GetThreadIdByHandle => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[20], :convention=>:stdcall  ),
        :GetNumberProcesses => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[21], :convention=>:stdcall  ),
        :GetProcessIdsByIndex => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG, PULONG], @vtable[22], :convention=>:stdcall  ),
        :GetCurrentProcessDataOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[23], :convention=>:stdcall  ),
        :GetProcessIdByDataOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[24], :convention=>:stdcall  ),
        :GetCurrentProcessPeb => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[25], :convention=>:stdcall  ),
        :GetProcessIdByPeb => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[26], :convention=>:stdcall  ),
        :GetCurrentProcessSystemId => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[27], :convention=>:stdcall  ),
        :GetProcessIdBySystemId => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG], @vtable[28], :convention=>:stdcall  ),
        :GetCurrentProcessHandle => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[29], :convention=>:stdcall  ),
        :GetProcessIdByHandle => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[30], :convention=>:stdcall  ),
        :GetCurrentProcessExecutableName => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[31], :convention=>:stdcall  ),
        :GetCurrentProcessUpTime => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[32], :convention=>:stdcall  ),
        :GetImplicitThreadDataOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[33], :convention=>:stdcall  ),
        :SetImplicitThreadDataOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[34], :convention=>:stdcall  ),
        :GetImplicitProcessDataOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[35], :convention=>:stdcall  ),
        :SetImplicitProcessDataOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[36], :convention=>:stdcall  ),
        :GetEventSystem => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[37], :convention=>:stdcall  ),
        :GetCurrentSystemId => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[38], :convention=>:stdcall  ),
        :SetCurrentSystemId => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[39], :convention=>:stdcall  ),
        :GetNumberSystems => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[40], :convention=>:stdcall  ),
        :GetSystemIdsByIndex => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG], @vtable[41], :convention=>:stdcall  ),
        :GetTotalNumberThreadsAndProcesses => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG, PULONG, PULONG, PULONG], @vtable[42], :convention=>:stdcall  ),
        :GetCurrentSystemServer => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[43], :convention=>:stdcall  ),
        :GetSystemByServer => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[44], :convention=>:stdcall  ),
        :GetCurrentSystemServerName => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[45], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end

  class DebugSystemObjects4

    NUM_APIS = 48

    include Win32::WinTypes

    def initialize( parent )

      # Get a pointer to the interface
      p=FFI::MemoryPointer.new(:pointer)
      parent.QueryInterface(IIDS[self.class.to_s], p)
      @interface_ptr = p.get_pointer(0)
      @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
        FFI::Pointer.new( addr )
      }

      # These are autogenerated from dbgeng.h and may contain errors!
      @api_dispatch_table={
        :QueryInterface => FFI::Function.new( HRESULT, [THIS_, REFIID, PVOID], @vtable[0], :convention=>:stdcall  ),
        :AddRef => FFI::Function.new( HRESULT, [THIS_], @vtable[1], :convention=>:stdcall  ),
        :Release => FFI::Function.new( HRESULT, [THIS_], @vtable[2], :convention=>:stdcall  ),
        :GetEventThread => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[3], :convention=>:stdcall  ),
        :GetEventProcess => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[4], :convention=>:stdcall  ),
        :GetCurrentThreadId => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[5], :convention=>:stdcall  ),
        :SetCurrentThreadId => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[6], :convention=>:stdcall  ),
        :GetCurrentProcessId => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[7], :convention=>:stdcall  ),
        :SetCurrentProcessId => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[8], :convention=>:stdcall  ),
        :GetNumberThreads => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[9], :convention=>:stdcall  ),
        :GetTotalNumberThreads => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG], @vtable[10], :convention=>:stdcall  ),
        :GetThreadIdsByIndex => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG, PULONG], @vtable[11], :convention=>:stdcall  ),
        :GetThreadIdByProcessor => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG], @vtable[12], :convention=>:stdcall  ),
        :GetCurrentThreadDataOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[13], :convention=>:stdcall  ),
        :GetThreadIdByDataOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[14], :convention=>:stdcall  ),
        :GetCurrentThreadTeb => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[15], :convention=>:stdcall  ),
        :GetThreadIdByTeb => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[16], :convention=>:stdcall  ),
        :GetCurrentThreadSystemId => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[17], :convention=>:stdcall  ),
        :GetThreadIdBySystemId => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG], @vtable[18], :convention=>:stdcall  ),
        :GetCurrentThreadHandle => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[19], :convention=>:stdcall  ),
        :GetThreadIdByHandle => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[20], :convention=>:stdcall  ),
        :GetNumberProcesses => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[21], :convention=>:stdcall  ),
        :GetProcessIdsByIndex => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG, PULONG], @vtable[22], :convention=>:stdcall  ),
        :GetCurrentProcessDataOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[23], :convention=>:stdcall  ),
        :GetProcessIdByDataOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[24], :convention=>:stdcall  ),
        :GetCurrentProcessPeb => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[25], :convention=>:stdcall  ),
        :GetProcessIdByPeb => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[26], :convention=>:stdcall  ),
        :GetCurrentProcessSystemId => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[27], :convention=>:stdcall  ),
        :GetProcessIdBySystemId => FFI::Function.new( HRESULT, [THIS_, ULONG, PULONG], @vtable[28], :convention=>:stdcall  ),
        :GetCurrentProcessHandle => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[29], :convention=>:stdcall  ),
        :GetProcessIdByHandle => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[30], :convention=>:stdcall  ),
        :GetCurrentProcessExecutableName => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[31], :convention=>:stdcall  ),
        :GetCurrentProcessUpTime => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[32], :convention=>:stdcall  ),
        :GetImplicitThreadDataOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[33], :convention=>:stdcall  ),
        :SetImplicitThreadDataOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[34], :convention=>:stdcall  ),
        :GetImplicitProcessDataOffset => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[35], :convention=>:stdcall  ),
        :SetImplicitProcessDataOffset => FFI::Function.new( HRESULT, [THIS_, ULONG64], @vtable[36], :convention=>:stdcall  ),
        :GetEventSystem => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[37], :convention=>:stdcall  ),
        :GetCurrentSystemId => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[38], :convention=>:stdcall  ),
        :SetCurrentSystemId => FFI::Function.new( HRESULT, [THIS_, ULONG], @vtable[39], :convention=>:stdcall  ),
        :GetNumberSystems => FFI::Function.new( HRESULT, [THIS_, PULONG], @vtable[40], :convention=>:stdcall  ),
        :GetSystemIdsByIndex => FFI::Function.new( HRESULT, [THIS_, ULONG, ULONG, PULONG], @vtable[41], :convention=>:stdcall  ),
        :GetTotalNumberThreadsAndProcesses => FFI::Function.new( HRESULT, [THIS_, PULONG, PULONG, PULONG, PULONG, PULONG], @vtable[42], :convention=>:stdcall  ),
        :GetCurrentSystemServer => FFI::Function.new( HRESULT, [THIS_, PULONG64], @vtable[43], :convention=>:stdcall  ),
        :GetSystemByServer => FFI::Function.new( HRESULT, [THIS_, ULONG64, PULONG], @vtable[44], :convention=>:stdcall  ),
        :GetCurrentSystemServerName => FFI::Function.new( HRESULT, [THIS_, PSTR_OUT, ULONG, PULONG], @vtable[45], :convention=>:stdcall  ),
        :GetCurrentProcessExecutableNameWide => FFI::Function.new( HRESULT, [THIS_, PWSTR_OUT, ULONG, PULONG], @vtable[46], :convention=>:stdcall  ),
        :GetCurrentSystemServerNameWide => FFI::Function.new( HRESULT, [THIS_, PWSTR_OUT, ULONG, PULONG], @vtable[47], :convention=>:stdcall  )
      }
    end

    def ptr
      @interface_ptr
    end

    def method_missing( meth, *args )
      raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
      @api_dispatch_table[meth].call( @interface_ptr, *args )
    end
  end


end
