# Let's never speak of this script again.

s=File.read ARGV[0]

klass_header = <<END

include Win32::WinTypes

def initialize( parent )

  # Get a pointer to the interface
  p=FFI::MemoryPointer.new(:pointer)
  parent.QueryInterface(IIDS[self.class.to_s], p)
  @interface_ptr = p.get_pointer(0)
  @vtable=@interface_ptr.get_pointer(0).read_array_of_pointer( NUM_APIS ).map {|addr|
    FFI::Pointer.new( addr )
  }

  # These are autogenerated from dbgeng.h and may contain errors!
  @api_dispatch_table={
END

    klass_footer = <<'END'
  }
end

def ptr
  @interface_ptr
end

def method_missing( meth, *args )
  raise ArgumentError, "#{self.class}: Invalid API #{meth}" unless @api_dispatch_table[meth]
  @api_dispatch_table[meth].call( @interface_ptr, *args )
end
end

END

apis=[]
defines = []
current_apis = []
this_api_args= []
this_api_comment = []
in_api=false
ruby_api_name=''
apiname=''
defstart =''
in_interface=false
counter=0

s.each_line {|l|
  if l=~ /\/\//
    next
  end
  if l=~/define/
    # Emit #defines, ones that occur in Interfaces will be defined as
    # constants, which is useful
    unless l =~ /#define INTERFACE/
      defines << "#{' '*4}#{l.squeeze(' ').split(' ').last(2).join( ' = ' )}"
    end
    next
  end
  if l=~/DECLARE_INTERFACE/
    # DECLARE_INTERFACE_(IDebugBreakpoint2, IUnknown)
    iface_name=l[/\(I(.*),/,1]
    apis << "  class #{iface_name}"
    apis.concat(defines)
    defines.clear
    in_interface=true
    counter=0
    next
  end
  if in_interface
    if l=~ /^\};/
      # End of DECLARE_INTERFACE.
      in_interface=false
      apis << "#{' '*4}NUM_APIS = #{current_apis.size/2}"
      current_apis.last.chop! # remove trailing comma
      apis << klass_header
      apis.concat current_apis
      current_apis.clear
      apis << klass_footer
      next
    end
    if l=~/STDMETHOD/
      apiname=l.match( /\((.*)\)/ )[1].tr(' ','').split(',').last
      # emit definition start
      defstart = "#{' '*8}:#{apiname} => FFI::Function.new( HRESULT, ["
      counter+=1
      in_api=true
      this_api_args=[]
      this_api_comment=[]
      next
    end
    if in_api

      # APIs look like this:
      #   STDMETHOD(GetCommand)(
      # THIS_
      # __out_ecount_opt(BufferSize) PSTR Buffer,
      # __in ULONG BufferSize,
      # __out_opt PULONG CommandSize
      # ) PURE;

      if l=~ /\) PURE;/
        # finish definition
        in_api=false
        current_apis << "#{' '*8}# #{apiname}(#{this_api_comment.join(" ")})"
        current_apis << defstart
        current_apis.last << this_api_args.join(', ') << "], @vtable[#{counter-1}], :convention=>:stdcall  ),"
        this_api_args=[]
        this_api_comment=[]
        next
      end

      args = l.split
      # Generally we'll have __in, __out, __out_opt etc etc too many options
      # SPACE <typename> (which we want) SPACE param name which is irrelevant
      if args[0]=~/THIS/
        this_api_comment << args.first

        # THIS_ doesn't have an in/out desc
        this_api_args << 'THIS_'
      else
        this_api_comment << "#{args.first[1..-1]}(#{args.last.tr(',','')})"

        # Used to translate here - not doing it anymore, we will use constants
        # to map ALL the required types to FFI typedefs, thus making the
        # autogen interfaces easier to read

        # Problem example: __out_bcount(ContextSize) /* align_is(16) */ PVOID Context,
        # Solution - take args[-2] not args[1]
        type = args[-2]
        if args[-2] =~ /P.*STR/ && args[0]=~/out/i
          # This creates a bullshit special type for any pointer to a string
          # that will be used for engine output. By doing this I can make the
          # FFI signatures take a :pointer for output strings, but use
          # :string for input strings, which is less fiddly for the user
          type = "#{args[-2]}_OUT"
        end

        if type && type[-1] == '*'
          type = type[0..-2]
        end

        if type == 'va_list'
          type = "PVA_LIST"
        end

        this_api_args << type

      end
      next
    end
  end
}
puts apis
